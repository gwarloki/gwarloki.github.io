{"title":"软件供应链分析工具-GoLang原生工具","uid":"9c3da876af68c4f62cd5f90bc6783fab","slug":"GoLang native sca tool for developer","date":"2022-09-14T02:13:00.000Z","updated":"2022-10-26T08:41:52.362Z","comments":true,"path":"api/articles/GoLang native sca tool for developer.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159414/4k-backlit-dawn-wallpapers-159414-29376-6050591.png","content":"<h1 id=\"GoLang-native-sca-tool-for-developer\"><a href=\"#GoLang-native-sca-tool-for-developer\" class=\"headerlink\" title=\"GoLang native sca tool for developer\"></a>GoLang native sca tool for developer</h1><h2 id=\"0x01简介\"><a href=\"#0x01简介\" class=\"headerlink\" title=\"0x01简介\"></a>0x01简介</h2><p>2022-09-06，Go 安全团队正式<a href=\"https://go.dev/blog/vuln\">对外宣布</a>Go漏洞管理工具 <a href=\"https://github.com/golang/vuln\">Govulncheck</a>， Govulncheck 是一款面向开发者的供应链漏洞检测工具，通过分析源代码或编译后的二进制文件，分析项目中引入的三方包及相关函数，然后在<a href=\"https://vuln.go.dev/\">漏洞库 https://vuln.go.dev/</a> 中查询是否是否存在漏洞。</p>\n<p>值得称赞的是， Govulncheck 在三方包的名称和版本进行漏洞匹配的基础上，<strong>还分析了三方包中的函数是否被调用，以及相关的调用路径</strong>。此外， Govulncheck 还结合了 Go 版本、操作系统的版本和架构做进一步的漏洞筛选，最终只展示在当前操作系统和 Go 语言版本中，具有真实危害的三方包。例如，对于 Linux 平台运行的二进制文件，不会报告具有 Windows 特定依赖条件的三方包漏洞，更详细的内容可以查看<a href=\"https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck#hdr-Limitations\">官方文档</a>。</p>\n<h2 id=\"0x02架构图\"><a href=\"#0x02架构图\" class=\"headerlink\" title=\"0x02架构图\"></a>0x02架构图</h2><p><img src=\"http://img.moses.wang/new/20220914101423.png\"></p>\n<h2 id=\"0x03核心能力\"><a href=\"#0x03核心能力\" class=\"headerlink\" title=\"0x03核心能力\"></a>0x03核心能力</h2><p>Govulncheck 通过分析二进制文件的符号信息查找出三方包及显式调用的函数，根据三方包和函数查找漏洞库，最终确定三方包是否存在漏洞，因此 Govulncheck 无法检测去除符号表信息的二进制文件。但是，生产环境中运行的 Go 二进制文件基本上都会去除符号表信息，减小体积并提高安全性。这一点也更加印证了 Govulncheck 的核心定位是一款为 Developer 开发的 DevSecOps 工具。 Govulncheck 还有一些其它的不足，比如：只支持 Go 1.18 及以上版本编译的二进制文件，分析二进制文件时无法展示漏洞调用图等，更多的限制信息可以查看<a href=\"https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck#hdr-Limitations\">官方博客</a>。</p>\n<h2 id=\"0x04-Theory\"><a href=\"#0x04-Theory\" class=\"headerlink\" title=\"0x04 Theory\"></a>0x04 Theory</h2><h3 id=\"分析代码原理\"><a href=\"#分析代码原理\" class=\"headerlink\" title=\"分析代码原理\"></a>分析代码原理</h3><p>流程如下：</p>\n<ol>\n<li>提取项目中使用到的三方组件和函数信息</li>\n<li>如果执行失败，则判断执行 <code>govulncheck</code> 命令的目录中是否存在 <strong>go.mod</strong> 和 <strong>go.sum</strong> 方法，输出相关的错误提示信息</li>\n<li>拉取三方组件相关的漏洞信息（该操作会优先检查本地文件缓存）</li>\n<li>根据三方组件和函数名称与漏洞信息进行匹配</li>\n<li>梳理三方组件函数的调用入口及相关的调用链路</li>\n<li>输出检测结果</li>\n</ol>\n<p><img src=\"http://img.moses.wang/new/20220914101711.png\"></p>\n<h3 id=\"分析二进制原理\"><a href=\"#分析二进制原理\" class=\"headerlink\" title=\"分析二进制原理\"></a>分析二进制原理</h3><p>整体流程如下：</p>\n<ol>\n<li>获取二进制文件的编译信息</li>\n<li>获取二进制文件内Go函数的符号名称，在 Golang 1.18 和 1.19 中，函数的符号名称为 <code>go.func.*</code>，Golang 1.20 中函数的符号名称为 <code>go:func.*</code></li>\n<li>获取二进制文件中的 pclntab 信息</li>\n<li>获取二进制文件的程序计数器及对应的行号，用于函数、语句、指令的位置</li>\n<li>根据程序计数器和对应的行号，解码为对应的符号表</li>\n<li>遍历符号表中的函数信息，获取函数名称、包名等信息</li>\n<li>拉取项目中使用到的三方包相关的漏洞信息到本地</li>\n<li>根据包名或包名与函数名称进行漏洞匹配</li>\n<li>输出检测结果<br><img src=\"http://img.moses.wang/new/20220914101919.png\"></li>\n</ol>\n<h2 id=\"0x05Quickstart\"><a href=\"#0x05Quickstart\" class=\"headerlink\" title=\"0x05Quickstart\"></a>0x05Quickstart</h2><h3 id=\"require\"><a href=\"#require\" class=\"headerlink\" title=\"require\"></a>require</h3><h3 id=\"install\"><a href=\"#install\" class=\"headerlink\" title=\"install\"></a>install</h3><h3 id=\"check\"><a href=\"#check\" class=\"headerlink\" title=\"check\"></a>check</h3><h3 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h3><h2 id=\"0x06使用说明\"><a href=\"#0x06使用说明\" class=\"headerlink\" title=\"0x06使用说明\"></a>0x06使用说明</h2><h2 id=\"0x07应用场景\"><a href=\"#0x07应用场景\" class=\"headerlink\" title=\"0x07应用场景\"></a>0x07应用场景</h2><h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><p><a href=\"https://exexute.github.io/2022/09/08/Go-Native-SCA-Tool-For-Developer/\">GoLang native sca tool for developer | owefsad 的博客</a><br><a href=\"https://go.dev/security/vuln/\">Go Vulnerability Management - The Go Programming Language</a><br><a href=\"https://go.dev/security/\">Go Security - The Go Programming Language</a></p>\n","text":"GoLang native sca tool for developer0x01简介2022-09-06，Go 安全团队正式对外宣布Go漏洞管理工具 Govulncheck， Govulncheck 是一款面向开发者的供应链漏洞检测工具，通过分析源代码或编译后的二进制文件，分析项...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"SCA","slug":"SCA","count":15,"path":"api/tags/SCA.json"},{"name":"GoLand","slug":"GoLand","count":1,"path":"api/tags/GoLand.json"},{"name":"软件成分分析工具","slug":"软件成分分析工具","count":5,"path":"api/tags/软件成分分析工具.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#GoLang-native-sca-tool-for-developer\"><span class=\"toc-text\">GoLang native sca tool for developer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x01%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">0x01简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x02%E6%9E%B6%E6%9E%84%E5%9B%BE\"><span class=\"toc-text\">0x02架构图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x03%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">0x03核心能力</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x04-Theory\"><span class=\"toc-text\">0x04 Theory</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E4%BB%A3%E7%A0%81%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">分析代码原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">分析二进制原理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x05Quickstart\"><span class=\"toc-text\">0x05Quickstart</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#require\"><span class=\"toc-text\">require</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#install\"><span class=\"toc-text\">install</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#check\"><span class=\"toc-text\">check</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">进阶</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x06%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">0x06使用说明</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#0x07%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">0x07应用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#References\"><span class=\"toc-text\">References</span></a></li></ol></li></ol>","author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"分布式系统学习-两段式&三段式提交","uid":"056884aed1b9e83f84ccf54a05d51c85","slug":"Two-phase commit","date":"2022-09-15T00:57:00.000Z","updated":"2022-10-27T05:30:33.363Z","comments":true,"path":"api/articles/Two-phase commit.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159416/4k-beneath-the-clouds-wallpapers-159416-910316-8960620.png","text":"Two-phase commit定义在分布式系统中，为了让每个节点都能够感知到其他节点的事务执行状况，需要引入一个中心节点来统一处理所有节点的执行逻辑，这个中心节点叫做协调者（Coordinator），被中心节点调度的其他业务节点叫做参与者（Participant）。 2PC 将...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"分布式","slug":"分布式","count":6,"path":"api/categories/分布式.json"}],"tags":[{"name":"三段式提交","slug":"三段式提交","count":1,"path":"api/tags/三段式提交.json"},{"name":"两段式提交","slug":"两段式提交","count":1,"path":"api/tags/两段式提交.json"},{"name":"分布式事务","slug":"分布式事务","count":1,"path":"api/tags/分布式事务.json"},{"name":"分布式系统","slug":"分布式系统","count":3,"path":"api/tags/分布式系统.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"CI/CD 过程中的部分pipeline","uid":"832ec458ec0531279eee1cd18e61ce2f","slug":"Jenkins pipeline","date":"2022-09-14T02:13:00.000Z","updated":"2022-10-26T09:18:52.847Z","comments":true,"path":"api/articles/Jenkins pipeline.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159414/4k-backlit-dawn-wallpapers-159414-29512-7452839.png","text":"DTimport hudson.model.*; import hudson.* import groovy.json.JsonSlurper; pipeline &#123; agent any tools &#123; &#x2F;&#x2F; maven &#39;mave...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"CI/CD","slug":"CI-CD","count":4,"path":"api/tags/CI-CD.json"},{"name":"SCA","slug":"SCA","count":15,"path":"api/tags/SCA.json"},{"name":"Jenkins","slug":"Jenkins","count":2,"path":"api/tags/Jenkins.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}