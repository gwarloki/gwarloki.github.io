{"title":"分布式系统学习-两段式&三段式提交","uid":"056884aed1b9e83f84ccf54a05d51c85","slug":"Two-phase commit","date":"2022-09-15T00:57:00.000Z","updated":"2022-10-27T05:30:33.363Z","comments":true,"path":"api/articles/Two-phase commit.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159416/4k-beneath-the-clouds-wallpapers-159416-910316-8960620.png","content":"<h1 id=\"Two-phase-commit\"><a href=\"#Two-phase-commit\" class=\"headerlink\" title=\"Two-phase commit\"></a>Two-phase commit</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>在分布式系统中，为了让每个节点都能够感知到其他节点的事务执行状况，需要引入一个中心节点来统一处理所有节点的执行逻辑，这个中心节点叫做协调者（Coordinator），被中心节点调度的其他业务节点叫做参与者（Participant）。</p>\n<p>2PC 将分布式事务分成了两个阶段，两个阶段分别为提交请求（投票）和提交（执行）。协调者根据参与者的响应来决定是否需要真正地执行事务，具体流程如下：<br><img src=\"http://img.moses.wang/new/20220915090338.png\"></p>\n<h3 id=\"提交请求（投票）阶段\"><a href=\"#提交请求（投票）阶段\" class=\"headerlink\" title=\"提交请求（投票）阶段\"></a>提交请求（投票）阶段</h3><ol>\n<li><p>协调者向所有参与者发送 prepare 请求与事务内容，询问是否可以准备事务提交，并等待参与者的响应。</p>\n</li>\n<li><p>参与者执行事务中包含的操作，并记录 undo 日志（用于回滚）和 redo 日志（用于重放），但不真正提交。</p>\n</li>\n<li><p>参与者向协调者返回事务操作的执行结果，执行成功返回 yes，否则返回 no。</p>\n</li>\n</ol>\n<h3 id=\"提交（执行）阶段\"><a href=\"#提交（执行）阶段\" class=\"headerlink\" title=\"提交（执行）阶段\"></a>提交（执行）阶段</h3><p>分为成功与失败两种情况。</p>\n<ul>\n<li>若所有参与者都返回 yes，说明事务可以提交：<ol>\n<li>协调者向所有参与者发送 Commit 请求。</li>\n<li>参与者收到 Commit 请求后，将事务真正地提交上去，并释放占用的事务资源，并向协调者返回 Ack。</li>\n<li>协调者收到所有参与者的 Ack 消息，事务成功完成。</li>\n</ol>\n</li>\n<li>若有参与者返回 no 或者超时未返回，说明事务中断，需要回滚：<ol>\n<li>协调者向所有参与者发送 Rollback 请求。</li>\n<li>参与者收到 Rollback 请求后，根据 undo 日志回滚到事务执行前的状态，释放占用的事务资源，并向协调者返回 Ack。</li>\n<li>协调者收到所有参与者的 Ack 消息，事务回滚完成。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"flink-2PC\"><a href=\"#flink-2PC\" class=\"headerlink\" title=\"flink 2PC\"></a>flink 2PC</h3><p>Flink 作为流式处理引擎，自然也提供了对 Exactly Once 语义的保证。端到端的 Exactly Once 语义，是输入、处理逻辑、输出三部分协同作用的结果。Flink 内部依托检查点机制和轻量级分布式快照算法 ABS 保证 Exactly Once。而要实现精确一次的输出逻辑，则需要施加以下两种限制之一：幂等性写入（idempotent write）、事务性写入（transactional write）。<br><strong>预提交阶段的流程</strong><br><img src=\"http://img.moses.wang/new/20220915090141.png\"><br>每当需要做 Checkpoint 时，JobManager 就在数据流中打入一个屏障（barrier），作为检查点的界限。屏障随着算子链向下游传递，每到达一个算子都会触发将状态快照写入状态后端的动作。当屏障到达 Kafka sink 后，通过 KafkaProducer.flush() 方法刷写消息数据，但还未真正提交。接下来还是需要通过检查点来触发提交阶段：<br><strong>提交阶段流程</strong><br><img src=\"http://img.moses.wang/new/20220915090217.png\"></p>\n<p>只有在所有检查点都成功完成这个前提下，写入才会成功。这符合前文所述 2PC 的流程，其中 JobManager 为协调者，各个算子为参与者（不过只有 Sink 一个参与者会执行提交）。一旦有检查点失败，notifyCheckpointComplete() 方法就不会执行。如果重试也不成功的话，最终会调用 abort() 方法回滚事务。</p>\n<h2 id=\"2PC的问题\"><a href=\"#2PC的问题\" class=\"headerlink\" title=\"2PC的问题\"></a>2PC的问题</h2><p><strong>同步阻塞问题</strong>：二阶段提交算法在执行过程中，所有参与节点都是事务阻塞型的。也就是说，当本地资源管理器占有临界资源时，其他资源管理器如果要访问同一临界资源，会处于阻塞状态。</p>\n<p><strong>协调者单点故障导致参与者长期阻塞问题</strong>：基于 XA 的二阶段提交算法类似于集中式算法，一旦事务管理器发生故障，整个系统都处于停滞状态。尤其是在提交阶段，一旦事务管理器发生故障，资源管理器会由于等待管理器的消息，而一直锁定事务资源，导致整个系统被阻塞。</p>\n<p><strong>数据不一致问题</strong>：在提交阶段，当协调者向参与者发送 DoCommit 请求之后，如果发生了局部网络异常，或者在发送提交请求的过程中协调者发生了故障，就会导致只有一部分参与者接收到了提交请求并执行提交操作，但其他未接到提交请求的那部分参与者则无法执行事务提交。于是整个分布式系统便出现了数据不一致的问题。</p>\n<p><strong>二阶段无法解决的问题</strong>：协调者再发出DoCommit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>\n<h2 id=\"3PC\"><a href=\"#3PC\" class=\"headerlink\" title=\"3PC\"></a>3PC</h2><p>三阶段提交协议（Three-phase commit protocol，3PC），是对二阶段提交（2PC）的改进。为了解决两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了<strong>超时机制</strong>和<strong>准备阶段</strong>。<br><strong>超时机制</strong></p>\n<p>同时在协调者和参与者中引入超时机制。如果协调者或参与者在规定的时间内没有接收到来自其他节点的响应，就会根据当前的状态选择提交或者终止整个事务。</p>\n<p><strong>准备阶段</strong></p>\n<p>在第一阶段和第二阶段中间引入了一个准备阶段，也就是在提交阶段之前，加入了一个预提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。<br><img src=\"http://img.moses.wang/new/20220915090558.png\"></p>\n<h3 id=\"CanCommit-阶段\"><a href=\"#CanCommit-阶段\" class=\"headerlink\" title=\"CanCommit 阶段\"></a>CanCommit 阶段</h3><p>协调者向参与者发送请求操作（CanCommit 请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到 CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。（<strong>我个人理解类似做TCC中Try操作</strong>）<br><img src=\"http://img.moses.wang/new/20220915094311.png\"><br><strong>PreCommit 阶段</strong></p>\n<p>协调者根据参与者的回复情况，来决定是否可以进行 PreCommit 操作 或 中断事务。</p>\n<p>如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：</p>\n<ul>\n<li>发送预提交请求。协调者向参与者发送 PreCommit 请求，进入预提交阶段。</li>\n<li>事务预提交。参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中，同时锁定当前记录。</li>\n<li>响应反馈。如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令</li>\n</ul>\n<p>如果任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：</p>\n<ul>\n<li>发送中断请求。协调者向所有参与者发送“Abort”消息。</li>\n<li>中断事务。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的中断操作。<br><img src=\"http://img.moses.wang/new/20220915094344.png\"><br><strong>DoCommit 阶段</strong></li>\n</ul>\n<p>协调者根据参与者的回复情况，来决定是否可以进行 DoCommit 操作 或 中断事务。</p>\n<p>如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的提交：</p>\n<ul>\n<li>发送提交请求。协调者接收到所有参与者发送的 Ack 响应，从预提交状态进入到提交状态，并向所有参与者发送 DoCommit 消息。</li>\n<li>事务提交。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源。</li>\n<li>响应反馈。参与者提交完事务之后，向协调者发送 Ack 响应。</li>\n<li>完成事务。协调者接收到所有参与者的 Ack 响应之后，完成事务。</li>\n</ul>\n<p>如果任何一个参与者向协调者发送了“No”消息，或者协调者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：</p>\n<ul>\n<li>发送中断请求。协调者向所有参与者发送 Abort 请求。</li>\n<li>事务回滚。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo 信息执行事务的回滚操作，并释放所有锁住的资源。</li>\n<li>反馈结果。参与者完成事务回滚之后，向协调者发送 Ack 消息。</li>\n<li>中断事务。协调者接收到参与者反馈的 Ack 消息之后，执行事务的中断，并结束事务。<br>。</li>\n</ul>\n<p>当参与者PreCommit 阶段向协调者发送 Ack 消息后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交那样被阻塞住</p>\n<p><img src=\"http://img.moses.wang/new/20220915094428.png\"></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><h3 id=\"如何解决协调者单点故障导致参与者长期阻塞。\"><a href=\"#如何解决协调者单点故障导致参与者长期阻塞。\" class=\"headerlink\" title=\"如何解决协调者单点故障导致参与者长期阻塞。\"></a>如何解决协调者单点故障导致参与者长期阻塞。</h3><p>由于存在超时机制，即使协调者发生故障，参与者无法及时收到来自协调者的信息之后，他会默认执行commit。避免参与者长期阻塞。</p>\n<h3 id=\"同步阻塞问题\"><a href=\"#同步阻塞问题\" class=\"headerlink\" title=\"同步阻塞问题\"></a>同步阻塞问题</h3><p>3PC会在2阶段到3阶段间阻塞，2PC会在1阶段到2阶段整个事务过程中阻塞，因而总体来说3PC并不能不阻塞，只是最大限度减少了阻塞的时间。同时安装5.2也能够解决协调者单点故障导致参与者长期阻塞的问题</p>\n<h3 id=\"数据不一致问题\"><a href=\"#数据不一致问题\" class=\"headerlink\" title=\"数据不一致问题\"></a>数据不一致问题</h3><p>3PC和2PC都无法解决数据一致的问题，不过3PC存在超时会通过超时保证协调者和参与者在提交阶段无法通信过程中最终一致，而不需人工介入。<br><img src=\"http://img.moses.wang/new/20220915094503.png\"></p>\n","text":"Two-phase commit定义在分布式系统中，为了让每个节点都能够感知到其他节点的事务执行状况，需要引入一个中心节点来统一处理所有节点的执行逻辑，这个中心节点叫做协调者（Coordinator），被中心节点调度的其他业务节点叫做参与者（Participant）。 2PC 将...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"分布式","slug":"分布式","count":6,"path":"api/categories/分布式.json"}],"tags":[{"name":"三段式提交","slug":"三段式提交","count":1,"path":"api/tags/三段式提交.json"},{"name":"两段式提交","slug":"两段式提交","count":1,"path":"api/tags/两段式提交.json"},{"name":"分布式事务","slug":"分布式事务","count":1,"path":"api/tags/分布式事务.json"},{"name":"分布式系统","slug":"分布式系统","count":3,"path":"api/tags/分布式系统.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Two-phase-commit\"><span class=\"toc-text\">Two-phase commit</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%90%E4%BA%A4%E8%AF%B7%E6%B1%82%EF%BC%88%E6%8A%95%E7%A5%A8%EF%BC%89%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">提交请求（投票）阶段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8F%90%E4%BA%A4%EF%BC%88%E6%89%A7%E8%A1%8C%EF%BC%89%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">提交（执行）阶段</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#flink-2PC\"><span class=\"toc-text\">flink 2PC</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2PC%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2PC的问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3PC\"><span class=\"toc-text\">3PC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CanCommit-%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">CanCommit 阶段</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%BB%93\"><span class=\"toc-text\">小结</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8D%8F%E8%B0%83%E8%80%85%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C%E5%AF%BC%E8%87%B4%E5%8F%82%E4%B8%8E%E8%80%85%E9%95%BF%E6%9C%9F%E9%98%BB%E5%A1%9E%E3%80%82\"><span class=\"toc-text\">如何解决协调者单点故障导致参与者长期阻塞。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">同步阻塞问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">数据不一致问题</span></a></li></ol></li></ol></li></ol>","author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"软件成分分析-Maven工作机制","uid":"e2099bf2ebd049ea8a6831d6aadccb72","slug":"Maven间接依赖场景的冲裁机制","date":"2022-09-22T02:42:00.000Z","updated":"2022-10-26T09:15:31.887Z","comments":true,"path":"api/articles/Maven间接依赖场景的冲裁机制.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159414/4k-backlit-dawn-wallpapers-159414-29418-4507433.png","text":"Maven间接依赖场景的冲裁机制BackendSSO统一权限父子项目中POM引用未规范，子工程POM引用了encrypt-body-spring-boot-starter-1.2.3.jar导致DT未检测出子项目的软件成分。 Concept坐标是什么？在空间坐标系中，我们可以通过...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"优秀文章收藏","slug":"优秀文章收藏","count":5,"path":"api/tags/优秀文章收藏.json"},{"name":"JAVA","slug":"JAVA","count":2,"path":"api/tags/JAVA.json"},{"name":"软件供应链安全","slug":"软件供应链安全","count":11,"path":"api/tags/软件供应链安全.json"},{"name":"软件成分分析","slug":"软件成分分析","count":2,"path":"api/tags/软件成分分析.json"},{"name":"Maven依赖","slug":"Maven依赖","count":1,"path":"api/tags/Maven依赖.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"软件供应链分析工具-GoLang原生工具","uid":"9c3da876af68c4f62cd5f90bc6783fab","slug":"GoLang native sca tool for developer","date":"2022-09-14T02:13:00.000Z","updated":"2022-10-26T08:41:52.362Z","comments":true,"path":"api/articles/GoLang native sca tool for developer.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159414/4k-backlit-dawn-wallpapers-159414-29376-6050591.png","text":"GoLang native sca tool for developer0x01简介2022-09-06，Go 安全团队正式对外宣布Go漏洞管理工具 Govulncheck， Govulncheck 是一款面向开发者的供应链漏洞检测工具，通过分析源代码或编译后的二进制文件，分析项...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"SCA","slug":"SCA","count":15,"path":"api/tags/SCA.json"},{"name":"GoLand","slug":"GoLand","count":1,"path":"api/tags/GoLand.json"},{"name":"软件成分分析工具","slug":"软件成分分析工具","count":5,"path":"api/tags/软件成分分析工具.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}