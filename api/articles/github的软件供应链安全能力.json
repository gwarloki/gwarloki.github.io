{"title":"代码托管平台的软件供应链安全能力介绍","uid":"139cfafc4597f90b4e444ece2c228d13","slug":"github的软件供应链安全能力","date":"2022-09-23T05:36:00.000Z","updated":"2022-10-26T07:58:14.718Z","comments":true,"path":"api/articles/github的软件供应链安全能力.json","keywords":null,"cover":"https://source.unsplash.com/pOwKTIgjKjU/1200x628","content":"<h1 id=\"github的软件供应链安全能力\"><a href=\"#github的软件供应链安全能力\" class=\"headerlink\" title=\"github的软件供应链安全能力\"></a>github的软件供应链安全能力</h1><h2 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h2><h3 id=\"关于Dependabot安全更新\"><a href=\"#关于Dependabot安全更新\" class=\"headerlink\" title=\"关于Dependabot安全更新\"></a>关于Dependabot安全更新</h3><p>Dependabot安全更新使您更容易修复存储库中的易受攻击的依赖项。如果您启用此功能，当在存储库的依赖关系图中为易受攻击的依赖项引发依赖项时，Dependabot会自动尝试修复它。有关更多信息，请参阅“<a href=\"https://docs.github.com/en/code-security/supply-chain-security/about-alerts-for-vulnerable-dependencies\">关于依赖机器人警报</a>”和“<a href=\"https://docs.github.com/en/github/managing-security-vulnerabilities/configuring-dependabot-security-updates\">配置依赖机器人安全更新</a>”。<br>GitHub可能会向受最近发布的GitHub安全公告披露的漏洞影响的存储库发送Dependabot警报。有关更多信息，请参阅“在<a href=\"https://docs.github.com/en/code-security/dependabot/dependabot-alerts/browsing-security-advisories-in-the-github-advisory-database\">GitHub咨询数据库中浏览安全建议</a>”。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意</strong>：Dependabot安全更新功能适用于您启用依赖关系图和Dependabot警报的存储库。您将看到完整依赖关系图中识别的每个脆弱依赖项的依赖项警报。但是，安全更新仅针对清单或锁定文件中指定的依赖项触发。有关更多信息，请参阅“<a href=\"https://docs.github.com/en/github/visualizing-repository-data-with-graphs/about-the-dependency-graph#dependencies-included\">关于依赖关系图</a>”。<br>对于npm，Dependabot将引发一个拉取请求，将显式定义的依赖项更新到安全版本，即使这意味着更新父依赖项或依赖项。对于其他生态系统，如果依赖项还需要更新父依赖项，则无法更新间接或传递依赖项。有关更多信息，请参阅“<a href=\"https://docs.github.com/en/code-security/dependabot/working-with-dependabot/troubleshooting-dependabot-errors#dependabot-tries-to-update-dependencies-without-an-alert\">Dependabot尝试在没有警报的情况下更新依赖项</a>”。</p></blockquote>\n<h3 id=\"配置-Dependabot-安全更新\"><a href=\"#配置-Dependabot-安全更新\" class=\"headerlink\" title=\"配置 Dependabot 安全更新\"></a>配置 Dependabot 安全更新</h3><p>操作详见<a href=\"https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/configuring-dependabot-security-updates\">Configuring Dependabot security updates - GitHub Docs</a></p>\n<h3 id=\"使用依赖项提交API\"><a href=\"#使用依赖项提交API\" class=\"headerlink\" title=\"使用依赖项提交API\"></a>使用依赖项提交API</h3><p>依赖项提交API允许您提交项目的依赖项。这使您能够将依赖项（例如在编译或构建软件时解决的依赖项）添加到GitHub的依赖关系图功能中，从而更完整地了解项目的所有依赖项。</p>\n<p>依赖项图显示您使用API提交的任何依赖项，以及从存储库中的清单或锁定文件中识别的任何依赖项（例如，JavaScript项目中的apackage<code>package-lock.json</code>文件）。有关查看依赖关系图的更多信息，请参阅“<a href=\"https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/exploring-the-dependencies-of-a-repository#viewing-the-dependency-graph\">探索存储库的依赖项</a>”。<br>依赖提交API<a href=\"https://docs.github.com/en/rest/dependency-graph/dependency-submission\">Dependency submission - GitHub Docs</a><br><strong>没有具体测试，不知道能不能扫描二进制文件包。</strong> 对比<br>[[2022-09-22_周四#腾讯云的二进制分析工具及其他安全能力]]</p>\n<h2 id=\"gitlab\"><a href=\"#gitlab\" class=\"headerlink\" title=\"gitlab\"></a>gitlab</h2><h3 id=\"依赖扫描Dependency-scanning\"><a href=\"#依赖扫描Dependency-scanning\" class=\"headerlink\" title=\"依赖扫描Dependency-scanning\"></a>依赖扫描Dependency-scanning</h3><p>依赖扫描通常被认为是软件组成分析（SCA）的一部分。SCA可以包含检查代码使用的项目的各个方面。这些项目通常包括应用程序和系统依赖项，这些依赖项几乎总是从外部来源导入，而不是从您自己编写的项目中获取。</p>\n<p>如果您正在使用<a href=\"https://docs.gitlab.com/ee/ci/index.html\">GitLab CI&#x2F;CD</a>，您可以使用依赖项扫描来分析您的依赖项是否存在已知漏洞。GitLab扫描所有依赖项，包括传递依赖项（也称为嵌套依赖项）。您可以通过以下任一方式利用依赖项扫描：</p>\n<ul>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/dependency_scanning/#configuration\">将依赖扫描模板包含在</a>您现有的<code>.gitlab-ci.yml</code>文件中。</li>\n<li>隐式使用<a href=\"https://docs.gitlab.com/ee/topics/autodevops/index.html\">Auto DevOps</a>提供的<a href=\"https://docs.gitlab.com/ee/topics/autodevops/stages.html#auto-dependency-scanning\">自动依赖扫描</a>。</li>\n</ul>\n<p>GitLab检查依赖项扫描报告，比较源分支和目标分支之间发现的漏洞，并显示合并请求的信息。结果按脆弱性的<a href=\"https://docs.gitlab.com/ee/user/application_security/vulnerabilities/severities.html\">严重程度</a>排序。</p>\n<h3 id=\"依赖扫描分析仪\"><a href=\"#依赖扫描分析仪\" class=\"headerlink\" title=\"依赖扫描分析仪\"></a>依赖扫描分析仪</h3><p>依赖扫描依赖于底层第三方工具，这些工具包含在我们所谓的“分析器”中。分析器是一个<a href=\"https://gitlab.com/gitlab-org/security-products/analyzers?_gl=1*emcpif*_ga*MzkxNzM5ODEyLjE2NjMyMTM3NDI.*_ga_ENFH3X7M5Y*MTY2MzkyMjg4NC43LjEuMTY2MzkyMjg5MC4wLjAuMA..\">专门的项目</a>，将特定工具包装到：</p>\n<ul>\n<li>公开其检测逻辑。</li>\n<li>处理其执行。</li>\n<li>将其输出转换为通用格式。</li>\n</ul>\n<h3 id=\"容器扫描分析器\"><a href=\"#容器扫描分析器\" class=\"headerlink\" title=\"容器扫描分析器\"></a>容器扫描分析器</h3><p>GitLab Container Scanning支持Trivy和Grype分析器。新版中更新如下：</p>\n<p>Trivy分析器更新到版本0.28.1。</p>\n<p>Grype分析器更新到版本0.38.0。</p>\n<h3 id=\"构建工件的SLSA-2\"><a href=\"#构建工件的SLSA-2\" class=\"headerlink\" title=\"构建工件的SLSA-2\"></a>构建工件的SLSA-2</h3><p>软件工件的供应链级别(SLSA)是一个安全框架，有助于确保软件供应链的安全性和完整性。默认情况下，GitLab Runner 现在能够为构建工件生成和生成符合SLSA-2的证明元数据。配置参考<a href=\"https://docs.gitlab.com/ee/ci/runners/configure_runners.html#attestation-format\">Configuring runners | GitLab</a></p>\n<h3 id=\"安全测试能力\"><a href=\"#安全测试能力\" class=\"headerlink\" title=\"安全测试能力\"></a>安全测试能力</h3><ul>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/sast/index.html\">静态应用程序安全测试</a>（SAST）<ul>\n<li>选择<strong>启用SAST</strong>为当前项目配置SAST。有关更多详细信息，请阅读<a href=\"https://docs.gitlab.com/ee/user/application_security/sast/index.html#configure-sast-in-the-ui\">用户界面中的配置SAST</a>。</li>\n</ul>\n</li>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/dast/index.html\">动态应用程序安全测试</a>（DAST）<ul>\n<li>选择<strong>启用DAST</strong>为当前项目配置DAST。</li>\n<li>选择<strong>管理扫描</strong>以管理保存的DAST扫描、站点配置文件和扫描仪配置文件。有关更多详细信息，请阅读<a href=\"https://docs.gitlab.com/ee/user/application_security/dast/index.html#on-demand-scans\">DAST按需扫描</a>。</li>\n</ul>\n</li>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/dependency_scanning/index.html\">依赖扫描</a><ul>\n<li>选择<strong>使用合并请求配置</strong>，以创建具有启用依赖项扫描所需更改的合并请求。有关更多详细信息，请参阅<a href=\"https://docs.gitlab.com/ee/user/application_security/dependency_scanning/index.html#enable-dependency-scanning-via-an-automatic-merge-request\">通过自动合并请求启用依赖项扫描</a>。</li>\n</ul>\n</li>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/container_scanning/index.html\">容器扫描</a><ul>\n<li>选择<strong>使用合并请求配置</strong>以创建具有启用容器扫描所需更改的合并请求。有关更多详细信息，请参阅<a href=\"https://docs.gitlab.com/ee/user/application_security/container_scanning/index.html#enable-container-scanning-through-an-automatic-merge-request\">通过自动合并请求启用容器扫描</a>。</li>\n</ul>\n</li>\n<li><a href=\"https://docs.gitlab.com/ee/user/clusters/agent/vulnerabilities.html\">操作容器扫描</a><ul>\n<li>可以通过向代理配置中添加配置块来进行配置。有关更多详细信息，请阅读<a href=\"https://docs.gitlab.com/ee/user/clusters/agent/vulnerabilities.html#enable-operational-container-scanning\">操作容器扫描</a>。</li>\n</ul>\n</li>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/secret_detection/index.html\">秘密检测</a><ul>\n<li>选择<strong>使用合并请求配置</strong>，以创建具有启用秘密检测所需更改的合并请求。有关更多详细信息，请阅读<a href=\"https://docs.gitlab.com/ee/user/application_security/secret_detection/index.html#enable-secret-detection-using-a-merge-request\">使用合并请求启用秘密检测</a>。</li>\n</ul>\n</li>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/api_fuzzing/index.html\">API模糊</a><ul>\n<li>选择<strong>启用API模糊</strong>，为当前项目使用API模糊。有关更多详细信息，请阅读<a href=\"https://docs.gitlab.com/ee/user/application_security/api_fuzzing/index.html#enable-web-api-fuzzing\">API Fuzzing</a>。</li>\n</ul>\n</li>\n<li><a href=\"https://docs.gitlab.com/ee/user/application_security/coverage_fuzzing/index.html\">覆盖范围模糊</a><ul>\n<li>可以使用<code>.gitlab-ci.yml</code>配置。有关更多详细信息，请阅读<a href=\"https://docs.gitlab.com/ee/user/application_security/coverage_fuzzing/index.html#enable-coverage-guided-fuzz-testing\">覆盖范围模糊</a>。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"OSSF最佳实践\"><a href=\"#OSSF最佳实践\" class=\"headerlink\" title=\"OSSF最佳实践\"></a>OSSF最佳实践</h2><p><a href=\"https://github.com/ossf/wg-best-practices-os-developers\">GitHub - ossf&#x2F;wg-best-practices-os-developers: The Best Practices for OSS Developers working group is dedicated to raising awareness and education of secure code best practices for open source developers.</a><br><a href=\"https://github.com/ossf/wg-best-practices-os-developers/blob/main/docs/Concise-Guide-for-Developing-More-Secure-Software.md#readme\">Concise-Guide-for-Developing-More-Secure-Software</a><br><a href=\"https://github.com/ossf/package-manager-best-practices\">package-manager-best-practices</a></p>\n<h3 id=\"知识库SKF\"><a href=\"#知识库SKF\" class=\"headerlink\" title=\"知识库SKF\"></a>知识库SKF</h3><p><a href=\"https://www.securityknowledgeframework.org/\">Security Knowledge Framework</a><br><a href=\"https://github.com/blabla1337/skf-flask\">GitHub - blabla1337&#x2F;skf-flask: Security Knowledge Framework (SKF) Python Flask &#x2F; Angular project</a><br><a href=\"https://demo.securityknowledgeframework.org/projects/summary/28\">Demo</a><br><a href=\"https://owasp-skf.gitbook.io/asvs-write-ups/\">SKF write-ups</a></p>\n<h2 id=\"CNCF\"><a href=\"#CNCF\" class=\"headerlink\" title=\"CNCF\"></a>CNCF</h2><p><a href=\"https://github.com/cncf/tag-security/tree/main/supply-chain-security/supply-chain-security-paper\">tag-security&#x2F;supply-chain-security&#x2F;supply-chain-security-paper at main · cncf&#x2F;tag-security · GitHub</a></p>\n","text":"github的软件供应链安全能力GitHub关于Dependabot安全更新Dependabot安全更新使您更容易修复存储库中的易受攻击的依赖项。如果您启用此功能，当在存储库的依赖关系图中为易受攻击的依赖项引发依赖项时，Dependabot会自动尝试修复它。有关更多信息，请参阅“...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"软件供应链安全","slug":"软件供应链安全","count":11,"path":"api/tags/软件供应链安全.json"},{"name":"Github","slug":"Github","count":1,"path":"api/tags/Github.json"},{"name":"Gitlab","slug":"Gitlab","count":1,"path":"api/tags/Gitlab.json"},{"name":"Dependabot","slug":"Dependabot","count":1,"path":"api/tags/Dependabot.json"},{"name":"Dependency-scanning","slug":"Dependency-scanning","count":1,"path":"api/tags/Dependency-scanning.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#github%E7%9A%84%E8%BD%AF%E4%BB%B6%E4%BE%9B%E5%BA%94%E9%93%BE%E5%AE%89%E5%85%A8%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">github的软件供应链安全能力</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#GitHub\"><span class=\"toc-text\">GitHub</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8EDependabot%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">关于Dependabot安全更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE-Dependabot-%E5%AE%89%E5%85%A8%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">配置 Dependabot 安全更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E9%A1%B9%E6%8F%90%E4%BA%A4API\"><span class=\"toc-text\">使用依赖项提交API</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#gitlab\"><span class=\"toc-text\">gitlab</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%89%AB%E6%8F%8FDependency-scanning\"><span class=\"toc-text\">依赖扫描Dependency-scanning</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E6%89%AB%E6%8F%8F%E5%88%86%E6%9E%90%E4%BB%AA\"><span class=\"toc-text\">依赖扫描分析仪</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%B9%E5%99%A8%E6%89%AB%E6%8F%8F%E5%88%86%E6%9E%90%E5%99%A8\"><span class=\"toc-text\">容器扫描分析器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E5%BB%BA%E5%B7%A5%E4%BB%B6%E7%9A%84SLSA-2\"><span class=\"toc-text\">构建工件的SLSA-2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">安全测试能力</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#OSSF%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">OSSF最佳实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9F%A5%E8%AF%86%E5%BA%93SKF\"><span class=\"toc-text\">知识库SKF</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CNCF\"><span class=\"toc-text\">CNCF</span></a></li></ol></li></ol>","author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"初识EasyOCR","uid":"a20fa276d43ad34e01f5a964480c687b","slug":"初识EasyOCR","date":"2022-10-20T09:53:00.000Z","updated":"2022-10-27T01:16:49.585Z","comments":true,"path":"api/articles/初识EasyOCR.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159414/4k-backlit-dawn-wallpapers-159414-29376-6050591.png","text":"EasyOCR0x01简介描述: EasyOCR 是一个用于从图像中提取文本的 python 模块, 它是一种通用的 OCR，既可以读取自然场景文本，也可以读取文档中的密集文本。目前支持 80 多种语言和所有流行的书写脚本，包括：拉丁文、中文、阿拉伯文、梵文、西里尔文等。除官网的...","link":"","photos":[],"count_time":{"symbolsCount":"8.4k","symbolsTime":"8 mins."},"categories":[{"name":"人工智能","slug":"人工智能","count":2,"path":"api/categories/人工智能.json"}],"tags":[{"name":"OCR","slug":"OCR","count":2,"path":"api/tags/OCR.json"},{"name":"深度学习","slug":"深度学习","count":1,"path":"api/tags/深度学习.json"},{"name":"神经网络","slug":"神经网络","count":1,"path":"api/tags/神经网络.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"软件成分分析-Maven工作机制","uid":"e2099bf2ebd049ea8a6831d6aadccb72","slug":"Maven间接依赖场景的冲裁机制","date":"2022-09-22T02:42:00.000Z","updated":"2022-10-26T09:15:31.887Z","comments":true,"path":"api/articles/Maven间接依赖场景的冲裁机制.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159414/4k-backlit-dawn-wallpapers-159414-29418-4507433.png","text":"Maven间接依赖场景的冲裁机制BackendSSO统一权限父子项目中POM引用未规范，子工程POM引用了encrypt-body-spring-boot-starter-1.2.3.jar导致DT未检测出子项目的软件成分。 Concept坐标是什么？在空间坐标系中，我们可以通过...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"优秀文章收藏","slug":"优秀文章收藏","count":5,"path":"api/tags/优秀文章收藏.json"},{"name":"JAVA","slug":"JAVA","count":2,"path":"api/tags/JAVA.json"},{"name":"软件供应链安全","slug":"软件供应链安全","count":11,"path":"api/tags/软件供应链安全.json"},{"name":"软件成分分析","slug":"软件成分分析","count":2,"path":"api/tags/软件成分分析.json"},{"name":"Maven依赖","slug":"Maven依赖","count":1,"path":"api/tags/Maven依赖.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}