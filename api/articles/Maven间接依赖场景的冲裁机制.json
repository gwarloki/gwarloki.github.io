{"title":"软件成分分析-Maven工作机制","uid":"e2099bf2ebd049ea8a6831d6aadccb72","slug":"Maven间接依赖场景的冲裁机制","date":"2022-09-22T02:42:00.000Z","updated":"2022-10-26T09:15:31.887Z","comments":true,"path":"api/articles/Maven间接依赖场景的冲裁机制.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159414/4k-backlit-dawn-wallpapers-159414-29418-4507433.png","content":"<h1 id=\"Maven间接依赖场景的冲裁机制\"><a href=\"#Maven间接依赖场景的冲裁机制\" class=\"headerlink\" title=\"Maven间接依赖场景的冲裁机制\"></a>Maven间接依赖场景的冲裁机制</h1><h2 id=\"Backend\"><a href=\"#Backend\" class=\"headerlink\" title=\"Backend\"></a>Backend</h2><p>SSO统一权限父子项目中POM引用未规范，子工程POM引用了<code>encrypt-body-spring-boot-starter-1.2.3.jar</code>导致DT未检测出子项目的软件成分。</p>\n<h2 id=\"Concept\"><a href=\"#Concept\" class=\"headerlink\" title=\"Concept\"></a>Concept</h2><h3 id=\"坐标是什么？\"><a href=\"#坐标是什么？\" class=\"headerlink\" title=\"坐标是什么？\"></a>坐标是什么？</h3><p>在空间坐标系中，我们可以通过xyz表示一个点，同样在Maven的世界里，我们可以通过一组GAV在依赖的世界里明确表示一个依赖，比如：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;groupId&gt; : com.alibaba 一般是公司的名称\n\n&lt;artifactId&gt; : fastjson 项目名称\n\n&lt;version&gt; : 1.2.24 版本号</code></pre>\n<h3 id=\"什么是PURL\"><a href=\"#什么是PURL\" class=\"headerlink\" title=\"什么是PURL\"></a>什么是PURL</h3><p>PURL(Package URL)用于定位一个产品或组件，见<a href=\"https://github.com/package-url/purl-spec\">GitHub - package-url&#x2F;purl-spec: A minimal specification for purl aka. a package “mostly universal” URL, join the discussion at https://gitter.im/package-url/Lobby</a><br>PURL由以下7个部分组成<br><code>scheme:type/namespace/name@version?qualifiers#subpath</code></p>\n<ul>\n<li><strong>scheme</strong>: this is the URL scheme with the constant value of “pkg”. One of the primary reason for this single scheme is to facilitate the future official registration of the “pkg” scheme for package URLs. Required.</li>\n<li><strong>type</strong>: the package “type” or package “protocol” such as maven, npm, nuget, gem, pypi, etc. Required.</li>\n<li><strong>namespace</strong>: some name prefix such as a Maven groupid, a Docker image owner, a GitHub user or organization. Optional and type-specific.</li>\n<li><strong>name</strong>: the name of the package. Required.</li>\n<li><strong>version</strong>: the version of the package. Optional.</li>\n<li><strong>qualifiers</strong>: extra qualifying data for a package such as an OS, architecture, a distro, etc. Optional and type-specific.</li>\n<li><strong>subpath</strong>: extra subpath within a package, relative to the package root. Optional.</li>\n</ul>\n<h4 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h4><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># bitbucket\npkg:bitbucket&#x2F;birkenfeld&#x2F;pygments-main@244fd47e07d1014f0aed9c\n# docker \npkg:docker&#x2F;cassandra@sha256:244fd47e07d1004f0aed9c\n# maven \npkg:maven&#x2F;org.apache.xmlgraphics&#x2F;batik-anim@1.9.1?packaging&#x3D;sources\n# rpm\npkg:rpm&#x2F;fedora&#x2F;curl@7.50.3-1.fc25?arch&#x3D;i386&amp;distro&#x3D;fedora-25\n# npm\npkg:npm&#x2F;%40angular&#x2F;animation@12.3.1</code></pre>\n<h3 id=\"依赖的标签\"><a href=\"#依赖的标签\" class=\"headerlink\" title=\"依赖的标签\"></a>依赖的标签</h3> <pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n\txsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n\t&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n\t&lt;groupId&gt;com.demo.springcloud&lt;&#x2F;groupId&gt;\n\t&lt;artifactId&gt;biz-service-0&lt;&#x2F;artifactId&gt;\n\t&lt;version&gt;1.0.0&lt;&#x2F;version&gt;\n\t&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;\n\n\t&lt;name&gt;biz-service-0&lt;&#x2F;name&gt;\n\t&lt;description&gt;Spring Cloud project&lt;&#x2F;description&gt;\n\n\t&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n\t\t&lt;version&gt;1.4.3.RELEASE&lt;&#x2F;version&gt;\n\t\t&lt;relativePath&#x2F;&gt; \n\t&lt;&#x2F;parent&gt;\n\n\t&lt;properties&gt;\n\t\t&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;\n\t\t&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;\n\t&lt;&#x2F;properties&gt;\n\n\t&lt;dependencies&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;\n\t\t&lt;&#x2F;dependency&gt;\n\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t\t&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n\t\t\t&lt;scope&gt;test&lt;&#x2F;scope&gt;\n\t\t&lt;&#x2F;dependency&gt;\n\t&lt;&#x2F;dependencies&gt;\n\n\t&lt;dependencyManagement&gt;\n\t\t&lt;dependencies&gt;\n\t\t\t&lt;dependency&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;\n\t\t\t\t&lt;version&gt;Brixton.RELEASE&lt;&#x2F;version&gt;\n\t\t\t\t&lt;type&gt;pom&lt;&#x2F;type&gt;\n\t\t\t\t&lt;scope&gt;import&lt;&#x2F;scope&gt;\n\t\t\t&lt;&#x2F;dependency&gt;\n\t\t&lt;&#x2F;dependencies&gt;\n\t&lt;&#x2F;dependencyManagement&gt;\n\n\t&lt;build&gt;\n\t\t&lt;plugins&gt;\n\t\t\t&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n\t\t\t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n\t\t\t&lt;&#x2F;plugin&gt;\n\t\t&lt;&#x2F;plugins&gt;\n\t&lt;&#x2F;build&gt;\n\n&lt;&#x2F;project&gt;</code></pre>\n\n<p>1.dependencies </p>\n<p>直接引入具体的依赖信息。注意是不在<code>dependencyManagement</code>标签内的情况。如果是在<code>dependencyManagement</code>内的情况，请参考2号标签。</p>\n<p>2.dependencyManagement <br><strong>只声明但不发生实际引入，作为依赖管理</strong>。依赖管理是指真正发生依赖的时候，再去参考依赖管理的数据。<br>这样使用dependency的时候，可以缺省version。<br>另外<code>dependencyManagement</code>还可以管控所有的间接依赖，即使间接依赖声明了version，也要被覆盖掉。   </p>\n<p>3.parent<br>声明自己的父亲，Maven的继承哲学跟Java很类似，因为Maven本身也是用Java实现的，满足单继承。</p>\n<ul>\n<li><p><strong>一旦子pom继承了父pom，那么会把父pom里的 <code>&lt;dependencies&gt; </code>，<code>&lt;dependencyManagement&gt;</code>等等属性都继承过来的。当然如果在继承的过程中，出现一样的元素，也是子去覆盖父亲，和Java类似。</strong></p>\n</li>\n<li><p>继承时，会<strong>分类继承</strong>。dependencies继承dependencies，dependencyManagement里的依赖管理只能继承dependencyManagement范围内的依赖管理。</p>\n</li>\n<li><p>每一个pom文件都会有一个父亲，<strong>即使不声明Parent，也会默认有一个父亲</strong>。和Java的Object设计哲学类似。后面在源码分析中我们还会提到。</p>\n</li>\n</ul>\n<p>4.properties</p>\n<p><strong>代表当前自己的项目的一个属性的集合。</strong> properties仅仅代表属性的声明，一个属性声明了，和他是否被引用并无关系。我完全可以声明一系列不被人使用的属性。</p>\n<h3 id=\"依赖的作用域\"><a href=\"#依赖的作用域\" class=\"headerlink\" title=\"依赖的作用域\"></a>依赖的作用域</h3><p>一个依赖在引入的时候，是可以声明这个依赖的作用范围的。比如这个依赖只对本地起作用，比如只对测试起作用等等。作用域一共有<strong>compile，provided，system，test，import，runtime</strong> 这几个值。</p>\n<ul>\n<li><p>compile和runtime会参与最后的打包环节，其余的都不会。compile可以不写。</p>\n</li>\n<li><p>test只会对 src&#x2F;test目录下的测试代码起作用。</p>\n</li>\n<li><p>provided是指线上已经提供了这个Jar包，打包的时候不需要在考虑他了，一般像serlvet的包很多都是provided。</p>\n</li>\n<li><p>system和provided没什么太大的区别。</p>\n</li>\n<li><p>import只会出现在dependencyManagement标签内的依赖中，是为了解决Maven的单继承。引入了这个作用域的话，maven会把此依赖的所有的dependencyManagement内的元素加载到当前pom中的，但不会引入当前节点。如下图，并不会引入fastjson作为依赖管理的元素，只是会把fastjson文件定义的依赖管理引入进来。</p>\n</li>\n</ul>\n<h2 id=\"单个树的依赖竞争\"><a href=\"#单个树的依赖竞争\" class=\"headerlink\" title=\"单个树的依赖竞争\"></a>单个树的依赖竞争</h2><h3 id=\"POM的本质\"><a href=\"#POM的本质\" class=\"headerlink\" title=\"POM的本质\"></a>POM的本质</h3><p><strong>一个Pom文件的本质就是一棵树。</strong><br>在人的视角来观察一个Pom文件的时候，我们会认为他是一个线状的一个依赖列表，我们会认为下图的Pom文件抽象出来的结果是C依赖了A,B,D。但我们的视角是不完备的，Maven的视角来看，Maven会把这一个Pom文件直接抽象成一个依赖树。Maven的视角能看到除了ABD之外的节点。而人只能看到ABD三个节点。<br>既然是在一棵树上，那么相同的节点就必然会存在竞争关系。这个竞争关系就是我们提到了仲裁机制。<br><img src=\"http://img.moses.wang/new/20220923174107.png\"></p>\n<h3 id=\"Maven的冲裁机制原则\"><a href=\"#Maven的冲裁机制原则\" class=\"headerlink\" title=\"Maven的冲裁机制原则\"></a>Maven的冲裁机制原则</h3><p><strong>1.依赖竞争时，越靠近主干的越优先。</strong></p>\n<p><strong>2.单颗树在依赖在竞争时(dependencies)（注意：不是dependencyManagement里的dependencies）：</strong></p>\n<ul>\n<li><p><strong>当deep&#x3D;1，即直接依赖。同级是靠后优先。</strong></p>\n</li>\n<li><p><strong>当deep&gt;1，即间接依赖。同级是靠前优先。</strong></p>\n</li>\n</ul>\n<p><strong>3.单颗树在依赖管理在竞争时(注意：是dependencyManagement里的dependencies)是靠前优先的。</strong></p>\n<p><strong>4.maven里最重要的2个关系，分别是继承关系和依赖关系。我们所有的规律都应该只从这2个关系入手。</strong></p>\n<p>下图中分别是2个子pom文件（方块代表依赖的节点，A-1 表示A这个节点使用的是1版本，字母代表节点，数字代表版本）。<br><img src=\"http://img.moses.wang/new/20220923174535.png\"><br>左边这个子pom生成的树依赖了 D-1，D-2和D-5。满足依赖竞争原则1，即越靠近树的左侧越优先的原则，所以D-5会竞争成功</p>\n<p>但是B-1和B-2同时都位于树的同一深度，并且深度为1，由于B-2更加靠后，所以B-2会竞争成功。</p>\n<p>右边的子pom生成的树依赖了 D-1和D-2，并且位于同一深度，但由于D-1和D-2是属于间接依赖的范围，deep大于1，所以是靠前优先，那么也就是D-1会竞争成功。</p>\n<h2 id=\"常见场景\"><a href=\"#常见场景\" class=\"headerlink\" title=\"常见场景\"></a>常见场景</h2><h2 id=\"Analyze\"><a href=\"#Analyze\" class=\"headerlink\" title=\"Analyze\"></a>Analyze</h2><h3 id=\"maven常用命令\"><a href=\"#maven常用命令\" class=\"headerlink\" title=\"maven常用命令\"></a>maven常用命令</h3><p>- mvn clean package -DSkipTest 直接进行打包，进行结果分析<br>- mvn dependency:tree 会把整个的maven的树形结构输出<br>- mvn help:effective-pom -Dverbose 这个命令输出的信息更加完整，输出的是effectivepom<br>- mvn clean org.apache.maven.plugins:maven-dependency-plugin:3.3.0:tree -Dverbose&#x3D;true<br>- mvn -D maven.repo.local &#x3D;你的目录 compile阶段用到的依赖。</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2>","text":"Maven间接依赖场景的冲裁机制BackendSSO统一权限父子项目中POM引用未规范，子工程POM引用了encrypt-body-spring-boot-starter-1.2.3.jar导致DT未检测出子项目的软件成分。 Concept坐标是什么？在空间坐标系中，我们可以通过...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"优秀文章收藏","slug":"优秀文章收藏","count":5,"path":"api/tags/优秀文章收藏.json"},{"name":"JAVA","slug":"JAVA","count":2,"path":"api/tags/JAVA.json"},{"name":"软件供应链安全","slug":"软件供应链安全","count":11,"path":"api/tags/软件供应链安全.json"},{"name":"软件成分分析","slug":"软件成分分析","count":2,"path":"api/tags/软件成分分析.json"},{"name":"Maven依赖","slug":"Maven依赖","count":1,"path":"api/tags/Maven依赖.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Maven%E9%97%B4%E6%8E%A5%E4%BE%9D%E8%B5%96%E5%9C%BA%E6%99%AF%E7%9A%84%E5%86%B2%E8%A3%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Maven间接依赖场景的冲裁机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Backend\"><span class=\"toc-text\">Backend</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Concept\"><span class=\"toc-text\">Concept</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9D%90%E6%A0%87%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">坐标是什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFPURL\"><span class=\"toc-text\">什么是PURL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#example\"><span class=\"toc-text\">example</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E7%9A%84%E6%A0%87%E7%AD%BE\"><span class=\"toc-text\">依赖的标签</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%9D%E8%B5%96%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">依赖的作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E4%B8%AA%E6%A0%91%E7%9A%84%E4%BE%9D%E8%B5%96%E7%AB%9E%E4%BA%89\"><span class=\"toc-text\">单个树的依赖竞争</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#POM%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">POM的本质</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Maven%E7%9A%84%E5%86%B2%E8%A3%81%E6%9C%BA%E5%88%B6%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">Maven的冲裁机制原则</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">常见场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Analyze\"><span class=\"toc-text\">Analyze</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">maven常用命令</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#References\"><span class=\"toc-text\">References</span></a></li></ol></li></ol>","author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"代码托管平台的软件供应链安全能力介绍","uid":"139cfafc4597f90b4e444ece2c228d13","slug":"github的软件供应链安全能力","date":"2022-09-23T05:36:00.000Z","updated":"2022-10-26T07:58:14.718Z","comments":true,"path":"api/articles/github的软件供应链安全能力.json","keywords":null,"cover":"https://source.unsplash.com/pOwKTIgjKjU/1200x628","text":"github的软件供应链安全能力GitHub关于Dependabot安全更新Dependabot安全更新使您更容易修复存储库中的易受攻击的依赖项。如果您启用此功能，当在存储库的依赖关系图中为易受攻击的依赖项引发依赖项时，Dependabot会自动尝试修复它。有关更多信息，请参阅“...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"软件供应链安全","slug":"软件供应链安全","count":26,"path":"api/categories/软件供应链安全.json"}],"tags":[{"name":"软件供应链安全","slug":"软件供应链安全","count":11,"path":"api/tags/软件供应链安全.json"},{"name":"Github","slug":"Github","count":1,"path":"api/tags/Github.json"},{"name":"Gitlab","slug":"Gitlab","count":1,"path":"api/tags/Gitlab.json"},{"name":"Dependabot","slug":"Dependabot","count":1,"path":"api/tags/Dependabot.json"},{"name":"Dependency-scanning","slug":"Dependency-scanning","count":1,"path":"api/tags/Dependency-scanning.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"分布式系统学习-两段式&三段式提交","uid":"056884aed1b9e83f84ccf54a05d51c85","slug":"Two-phase commit","date":"2022-09-15T00:57:00.000Z","updated":"2022-10-27T05:30:33.363Z","comments":true,"path":"api/articles/Two-phase commit.json","keywords":null,"cover":"https://gtwallpaper.org/sites/default/files/wallpaper/159416/4k-beneath-the-clouds-wallpapers-159416-910316-8960620.png","text":"Two-phase commit定义在分布式系统中，为了让每个节点都能够感知到其他节点的事务执行状况，需要引入一个中心节点来统一处理所有节点的执行逻辑，这个中心节点叫做协调者（Coordinator），被中心节点调度的其他业务节点叫做参与者（Participant）。 2PC 将...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"分布式","slug":"分布式","count":6,"path":"api/categories/分布式.json"}],"tags":[{"name":"三段式提交","slug":"三段式提交","count":1,"path":"api/tags/三段式提交.json"},{"name":"两段式提交","slug":"两段式提交","count":1,"path":"api/tags/两段式提交.json"},{"name":"分布式事务","slug":"分布式事务","count":1,"path":"api/tags/分布式事务.json"},{"name":"分布式系统","slug":"分布式系统","count":3,"path":"api/tags/分布式系统.json"}],"author":{"name":"Moses","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}