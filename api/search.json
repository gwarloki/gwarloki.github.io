[{"id":"0f4f52fd9bba6992ed16037b649e9241","title":"软件成分分析工具评估开放指南","content":"1.介绍   借助软件成分分析（SCA）工具，软件开发团队能从许可证合规和安全漏洞角度跟踪和分析引入到项目里的任何开源代码。这样的工具发现开源代码（不同程度的细节和功能），他们直接和间接依赖、许可证有效性，和任何已知的安全漏洞及潜在的攻击。好多公司提供软件成分分析（SCA）工具套装、开源工具、作为社区项目驱动的相关服务。总有关于什么工具最适合特定的模型和环境的问题，缺少对比和评估工具的标准方法，很难回答这个问题。因此，本文的目标是推荐一系列对比指标，用以评价多个软件成分分析（SCA）工具。\n   本文是《企业中开源软件合规性》（第二版）一书中第12章的重大更新版。这本书记录和发布了对比及评估软件成分分析（SCA）工具的指标，搜集反馈、推动建立对比和评测的标准化模型。请注意，没有“一劳永逸”的方案，在市场上有许多工具，具有不同功能、成熟度水平、部署模型等。当你开始这段旅程时，我们强烈推荐你根据特定环境和要求，确定最想要的功能，然后根据这些指标对工具进行测试和评分。\n2.评估指标2.1. 知识库\n知识库的大小通常以开源项目的数量和跟踪文件的数量来衡量。知识库存储开源软件的信息，数据库越大，当你扫描时，就能识别更多的开源代码。\n\n列出跟踪的主要库（如所有NPM，SourceForge等）\n\n跟踪哪些生态系统（如R，Delphi等）\n\n范围中包括什么语言（基于扩展和库类型）。理想情况是，扫描器应该和语言无关；然而，基本没有厂商提供这种支持，因此需要澄清支持什么语言\n\n区分包之间的检测级别（如Maven和“Java”支持，例如，你能发现jar依赖，但实际上不扫描.java源文件的版权&#x2F;许可证信息）\n\n知识库更新频率。频率高的更新更受欢迎，和开源软件的发展保持一致。合规服务和工具提供商有定期更新他们的数据库。有的公司每年更新三到四次，其他公司则频率更高（直到每天），理想情况下，你希望有最大和最新的数据库，增加识别新发布的开源代码的机会。\n\n一个客户的需求多久能被添加到知识库中，对客户需求响应有服务水平协议（SLA）吗？流程是什么？\n\n\n2.2. 检测能力\n整体组件\n\n纠正&#x2F;配置分析器的能力-软件项目很复杂，有不同的构建步骤，需要一个方法去配置工具，捕获现实\n\n检测使用的方法是什么？不同的分析方法各有优缺点，工具生成者应该总结每个使用的扫描器，如何帮助检测。\n\n部分片段-从几行到部分文件\n\n提供什么选项来纠正和验证结果？支持结果排序功能吗（例如P1或严重级）？\n\n自动识别具有正确来源和许可证的代码，不需要合规工程师操作工具来判断什么是正确的匹配，什么是误报。许多源代码扫描引擎，特别是支持片段扫描，能够生成相当数量的误报，需要调查和手动解决。误报率导致的大量人力消耗，是今天市场上很多最出名产品一直存在的问题。当评估这样的产品时，我们推荐优先考虑能自动识别源代码片段，具有需要手动检查的最小误报率。\n\n支持哪种类型的分析（包检测，精确文件类型检测，用来发现单个源文件、二进制文件、多媒体文件）\n\n源代码扫描（代码-&gt;属于哪个开源软件包）？\n\n二进制扫描（二进制-&gt;属于哪个开源软件包）？\n\n片段扫描（代码片段-&gt;拷贝于哪个开源软件包）？\n\n依赖扫描（代码-&gt; 通过包管理器，包含哪个依赖）？\n\n许可证扫描（代码-&gt;开源软件许可证）\n\n支持什么语言?如果支持某种语言，也支持片段分析吗？仅限于包水平吗？精确文件匹配？\n\n安全扫描器（代码-&gt;漏洞？）\n\n其他漏洞检测技术，包括搜索术语，电子邮件&#x2F;URL检测，web服务检测等\n\n\n2.3易用性易用性很重要，因为如果你所有的工程师要访问和使用扫描工具（而不是仅限合规工程师），你可以在合规问题出现之前和工程师使用构建工具集成新代码之前，避免合规问题，你将想要一个容易使用的工具，最小化学习曲线，避免高成本专业培训。\n\n直观的设计和用户界面\n\n本地客户端或浏览器插件可用\n\n移动用户可用\n\n要求最小或不需要培训，培训用来“了解如何检查和评估结果”。请注意，易用性是一个非常主观的标准，很难量化或定性。然而，一些工具确实比其他工具更易于使用。\n\n\n \n2.4. 操作功能\n源代码扫描速度：源代码扫描的速度是今天市场上许多产品的痛点。例如，一个公司设计和开发了自己的数据库，非常适合操作这种类型的数据。因此，他们有一个闪电般扫描速度，比其他现有工具都快。此外，当你把持续集成流程和扫描器集成时，扫描速度特别有用。需要注意的地方，一个是文件被跳过时速度问题，另一个问题是，是否真正执行了版权和许可证检测，或仅仅扫描库&#x2F;包管理文件，如pom.xml文件。\n\n使用工具进行和收购活动相关的扫描，在使用模式上不要有许可证锁定。一些厂商通过许可证协议，只允许扫描和当前项目有关的代码，对这之外的使用场景加以限制。你需要清楚这个事实，确信你能充分使用该工具，例如，对你公司正在考虑的任何并购交易。\n\n编程语言无关：一些工具创建者承认，他们的产品非常擅长某种编程语言，但对其他的则不行。这很有趣，因为你希望任何扫描和识别引擎都应该和编程语言无关，大多数工具并非如此，几乎没有和语言无关的。\n\n整个组织中，重复使用扫描澄清（scan clarification）的功能。\n\n和构建系统（CD&#x2F;CI）无关。。\n\n\n2.5 集成功能\n提供容易集成的API，和命令行接口（CLI）：使用扫描工具的方式不仅限于用户界面。理想情况，公司希望工具和他们当前的开发、构建及流程集成到一起。如果扫描工具支持API，CLI将允许系统管理员和用户界面之外的工具交互，这样的场景是可行的。。\n\n支持用户界面（UI）集成功能。\n\n将组织的合规策略集成到工具内，当和声明的策略及规则有关时，具有规则标记码（flag code）。\n\n\n2.6.  安全漏洞数据库\n漏洞数据库的规模-所有项目中跟踪的漏洞数量：数据库包含已知漏洞信息，能支持工具检测源代码中安全相关的问题。请注意“源代码”一词，没有特别指定是开源组件或第三方组件。如果复制的代码包含已知安全漏洞，当你扫描私有组件时，你的引擎应该能标记这个漏洞。\n\n漏洞数据库更新频率：服务提供商定期更新他们的数据库，更新周期越短，也就能更好地发现漏洞。\n\n漏洞信息源的数量：多个信息源能够充实开源组件中安全漏洞数据库。当评估提供这个服务的合规工具时，我们推荐调查这个方面和探索实际上的更新机制。使用各种信息源（直接和间接）来收集安全漏洞的信息，在这个基础上，提出修复这些漏洞的建议。\n\n工具提供商为验证漏洞报警，而从事的任何其他研究。\n\n精确度（漏洞被正确识别的比率）。有四个级别的准确率。\n\n\n  - 1 存在漏洞的软件已经被正确地对应到我们私有软件中实际使用的依赖项  - 2 依赖项用在重要的环境（运行时）。  - 3 在重要环境中的私有软件调用了依赖项的漏洞部分。  - 4 漏洞可被攻破。\n\n召回率（recall）（发现了多少潜在的真实漏洞，并正确匹配到私有软件？）。实际上，这不可能知道。对比不同的解决方案，对特定的技术栈，估计什么方案具有最高的召回率。\n\n上下文相关的漏洞排序功能。常见漏洞严重性排名，如CVSS3，由于私有软件的环境，可能不准确。用户应该能够关联漏洞的严重性来排序，以便更准确解决安全威胁。\n\n\n2.7高级漏洞发现方法   支持高级漏洞发现，当有漏洞的代码复制到一个新组件时（要求支持源代码片段识别），识别漏洞。\n2.8.相关成本需要考虑几个成本参数：\n\n基础设施成本：IT 基础设施成本和自己安装或通过云使用有关。涉及到客户需要购买、安装和维护的服务器，包括升级基础设施费用，取决于规模、专门的系统管理员成本的多少。\n\n运维成本：成本和管理工具提供的结果有关，涉及到检查和解释结果，采取合适的行动，自动识别误报的工具将降低人工确认上千个误报的人力成本。\n\n每年许可证成本：使用工具的每年软件许可费用（每用户成本、或不限使用）。访问SDK成本，这样你能把扫描引擎和内部工具集成起来，以及任何您想要引入的功能、满足需求，定制化的成本。\n\n和现有引擎&#x2F;IT工具和基础设施集成初始成本：集成费用很难估计，但他们主要是不断发展能力，把工具集成到工作流和流程中，最小中断。\n\n导出项目和其他信息的能，可能是转移到一个新系统，或者是离开旧厂商保留知识。\n\n绑定成本（如果你需要退出并采用其他方案时，需要考虑的成本因素）：当围绕着特定工具，打造整个合规环境，公司常常忽视或没有足够的重视绑定因素和成本。当选择一个新工具之初，我们建议在这个方面考虑周全。\n\n符合特定需要的工程定制成本\n\n\n2.9 部署模型的支持支持各种部署模型：\n\n本地\n\n云\n\n混合部署\n\n\n你的代码和项目留给网络什么信息？对最终用户要非常透明：\n\n源代码和二进制文件内容\n\n部分文件内容&#x2F;字符串\n\n哈希值\n\n编录清单\n\n策略信息\n\n合规&#x2F;不合规状态\n\n\n2.10 报告功能\n生成要求的合规通知：通知是基于实际扫描结果或者是仅仅从知识库拉取的许可证信息？\n\n子组件和子文件是什么？通知中包括实际版权&#x2F;许可证吗？\n\n开源代码片段的通知是什么？\n\n支持各种报告功能-输出各种格式的报告，如Excel&#x2F;电子表格（Spreadsheet）（包括提供详细报告样本）\n\n支持开放标准格式（软件包数据交换（software，package data exchange，SPDX），SARIF，CVE，CVSS等）\n\n\n概念解释参考标准\n\n\nSeries &amp; Number\nTitle\nStatus\nReleased\n\n\n\nSP 800-218\nSecure Software Development Framework (SSDF) Version 1.1: Recommendations for Mitigating the Risk of Software Vulnerabilities\nFinal\n02&#x2F;03&#x2F;2022\n\n\nSP 800-218 (Draft)\nSecure Software Development Framework (SSDF) Version 1.1: Recommendations for Mitigating the Risk of Software Vulnerabilities\nDraft\n09&#x2F;30&#x2F;2021\n\n\nWhite Paper NIST CSWP 13\nMitigating the Risk of Software Vulnerabilities by Adopting a Secure Software Development Framework (SSDF)\nWithdrawn\n04&#x2F;23&#x2F;2020\n\n\n📚参考资料\nNIST.SP.800-218.pdfhttps://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-218.pdf\nNIST.CSWP.04232020.pdfhttps://nvlpubs.nist.gov/nistpubs/CSWP/NIST.CSWP.04232020.pdf\n\n","slug":"软件成分分析工具评估开放指南","date":"2022-10-26T01:08:35.000Z","categories_index":"","tags_index":"SCA,软件成分分析,评估开放指南,产品选型","author_index":"Moses"},{"id":"afb19c047533022f884066f88b6a2608","title":"软件供应链安全分析工具-Dependency-Track","content":"dependency-track概述和背景[[SCA软件成分分析前期探索#OWASP Dependency-Track]]\n部署DTquick-start[[SCA软件成分分析前期探索#部署]]docker安装版本为V3.8.0\nK8S部署helm-charts前期准备：安装SC\n\n快速使用[[longhorn]]\n\n设置默认存储类\nkubectl patch storageclass longhorn -p &#39;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io&#x2F;is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#39;\n使用Helm v3安装\nhelm repo add evryfs-oss https:&#x2F;&#x2F;evryfs.github.io&#x2F;helm-charts&#x2F;\nhelm install dependency-track evryfs-oss&#x2F;dependency-track --namespace dependency-track --create-namespace\n创建路由\n\n配置config.json\n&#x2F;app&#x2F;static $ cat config.json\n&#123;\n  &quot;API_BASE_URL&quot;: &quot;http:&#x2F;&#x2F;dt-api.kubegems.io:32126&quot;,\n  &quot;OIDC_ISSUER&quot;: &quot;&quot;,\n  &quot;OIDC_CLIENT_ID&quot;: &quot;&quot;,\n  &quot;OIDC_SCOPE&quot;: &quot;openid profile email&quot;,\n  &quot;OIDC_FLOW&quot;: &quot;&quot;,\n  &quot;OIDC_LOGIN_BUTTON_TEXT&quot;: &quot;&quot;\n&#125;\n测试登录-修改密码-创建测试项目.漏洞分析及依赖图谱如下：\n\n\n\n\n一段事件后backend服务出现装载卷失败(也有可能是CPU的问题)Dependency Track High CPU Behaviour · Issue #264 · DependencyTrack&#x2F;dependency-track · GitHub，尝试各种回滚、扩容等方式失败后重新部署，重新部署可能是Longhorn的PV卷未删除导致安装失败，不能创建PVC。修改value文件后重新安装成功。# 下载chart\nhelm fetch evryfs-oss&#x2F;dependency-track\n# 解压\ntar -zxf dependency-track-1.4.0.tgz\n# 修改value.yaml文件，更换SC，使用local-path\nvi value.yaml \n# 修改postgresql的部署文件，更换sc,使用local-path\nvim deployment.yaml\n# 重新安装\nhelm install -f values.yaml dependency-track . --namespace dependency-track --create-namespace\n\nDT更换数据库Dependency-Track更换数据库文档适用于docker部署，K8S暂未研究\nSBOM[[软件物料清单SBOM]]CycloneDX工具CycloneDX Tool Center\ncdxgen\n项目地址cdxgen\n官网Scan docs\n\n安装测试xfxj01@moses  ~&#x2F;Downloads  nvm install v16.15.1\nxfxj01@moses  ~&#x2F;Downloads  npm install -g @appthreat&#x2F;cdxgen\n\n使用场景使用场景和更多的功能为深入研究，详见官网\nCycloneDX Maven Plugin在项目pom文件的plugin中引入\n&lt;plugin&gt;\n\t\t\t\t&lt;groupId&gt;org.cyclonedx&lt;&#x2F;groupId&gt;\n\t\t\t\t&lt;artifactId&gt;cyclonedx-maven-plugin&lt;&#x2F;artifactId&gt;\n\t\t\t\t&lt;version&gt;2.5.1&lt;&#x2F;version&gt;\n\t\t\t\t&lt;executions&gt;\n\t\t\t\t\t&lt;execution&gt;\n\t\t\t\t\t\t&lt;phase&gt;package&lt;&#x2F;phase&gt;\n\t\t\t\t\t\t&lt;goals&gt;\n\t\t\t\t\t\t\t&lt;goal&gt;makeAggregateBom&lt;&#x2F;goal&gt;\n\t\t\t\t\t\t&lt;&#x2F;goals&gt;\n\t\t\t\t\t&lt;&#x2F;execution&gt;\n\t\t\t\t&lt;&#x2F;executions&gt;\n\t\t\t\t&lt;configuration&gt;\n\t\t\t\t\t&lt;projectType&gt;library&lt;&#x2F;projectType&gt;\n\t\t\t\t\t&lt;schemaVersion&gt;1.3&lt;&#x2F;schemaVersion&gt;\n\n\t\t\t\t\t&lt;includeBomSerialNumber&gt;true&lt;&#x2F;includeBomSerialNumber&gt;\n\n\t\t\t\t\t&lt;includeCompileScope&gt;true&lt;&#x2F;includeCompileScope&gt;\n\n\t\t\t\t\t&lt;includeProvidedScope&gt;true&lt;&#x2F;includeProvidedScope&gt;\n\n\t\t\t\t\t&lt;includeRuntimeScope&gt;true&lt;&#x2F;includeRuntimeScope&gt;\n\n\t\t\t\t\t&lt;includeSystemScope&gt;true&lt;&#x2F;includeSystemScope&gt;\n\n\t\t\t\t\t&lt;includeTestScope&gt;false&lt;&#x2F;includeTestScope&gt;\n\n\t\t\t\t\t&lt;includeLicenseText&gt;false&lt;&#x2F;includeLicenseText&gt;\n\n\t\t\t\t\t&lt;outputFormat&gt;all&lt;&#x2F;outputFormat&gt;\n\n\t\t\t\t\t&lt;outputName&gt;bom&lt;&#x2F;outputName&gt;\n\n\t\t\t\t&lt;&#x2F;configuration&gt;\n\n\t\t\t&lt;&#x2F;plugin&gt;\n\nCycloneDX BOMs RepoDT不支持存储原始BOM文件，可以使用BOM Repo进行存储cyclonedx-bom-repo-server使用docker部署\n# 本地测试\ndocker run --env REPO__DIRECTORY&#x3D;&#x2F;repo --env ALLOWEDMETHODS__GET&#x3D;&quot;true&quot; --env ALLOWEDMETHODS__POST&#x3D;&quot;true&quot; --env ALLOWEDMETHODS__DELETE&#x3D;&quot;true&quot; --tty --interactive -p 8000:8080 cyclonedx&#x2F;cyclonedx-bom-repo-server\n# 持久化存储\nmkdir repo\ndocker run --volume &quot;$(pwd)&#x2F;repo&quot;:&#x2F;repo --env REPO__DIRECTORY&#x3D;&#x2F;repo --env ALLOWEDMETHODS__GET&#x3D;&quot;true&quot; --env ALLOWEDMETHODS__POST&#x3D;&quot;true&quot; --env ALLOWEDMETHODS__DELETE&#x3D;&quot;true&quot; --tty --interactive -p 8000:8080 cyclonedx&#x2F;cyclonedx-bom-repo-server\n\n安装Jenkins测试环境docker run -d -p 8222:8080 -u root  -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock jenkinsci&#x2F;blueocean:latest\n# 初始密码\ncat &#x2F;var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword\n安装CI&#x2F;CD插件\n安装OWASP Dependency-Track插件\n\n系统配置\n\n配置maven及JDK环境变量\n\nbuild测试\ncd hctc-auditor-message-master-42d51509695f2e19d602bfed846d71b052151176\n# 打包\nmvn clean install -D mvn.test.skip&#x3D;true\n# 生成bom.xml文件\nmvn org.cyclonedx:cyclonedx-maven-plugin:makeBom\n\n\n构建后操作\n\n\n\n在【Build】处选择“Execute Shell”，然后输入构建语句，并添加mvn org.cyclonedx:cyclonedx-maven-plugin:makeAggregateBom生成sbom文件\n在【Post-build Actions】处选择“Publish BOM to Dependency-Track”,填写project name 和 project version，在“Artifact”处输入$&#123;WORKSPACE&#125;/target/bom.json\n\n\n测试结果测试过程先在DT中创建的项目，不知道能不能自动创建\n测试pipeline项目-创建API1.首先在Dependency-Track中点击【Administration】-&gt; 【Access Management】-&gt;【Teams】,创建一个Team并记录其API Key。\n2.API Key 添加PROJECT_CREATION_UPLOAD权限\npipeline scriptpipeline &#123;\n    agent any\n    stages &#123;\n        stage(&#39;Start&#39;) &#123;\n           steps &#123;\n               echo &#39;Hello World&#39;\n           &#125;\n       &#125;\n       stage(&#39;Build&#39;) &#123;\n           steps &#123;\n                git &#39;https:&#x2F;&#x2F;github.com&#x2F;sohutv&#x2F;cachecloud.git&#39;\n                sh &quot;mvn -DskipTests&#x3D;true clean package&quot;\n            &#125;\n       &#125;\n        stage(&#39;Generating SBOM with Cyclonedx&#39;) &#123;\n            steps &#123;\n                sh &#39;mvn org.cyclonedx:cyclonedx-maven-plugin:makeAggregateBom&#39;\n            &#125;\n        &#125;\n        stage(&#39;dependencyTrackPublisher&#39;) &#123;\n            steps &#123;\n                withCredentials([string(credentialsId: &#39;dt&#39;, variable: &#39;API_KEY&#39;)]) &#123;\n                    dependencyTrackPublisher artifact: &#39;target&#x2F;bom.xml&#39;, projectId: &#39;534a7d70-c510-4770-8796-2abdac6f55d7&#39;,  autoCreateProjects: true, dependencyTrackApiKey:API_KEY, synchronous: false\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n参考 OWASP Dependency-Track Plugin\n问题 使用projectName和projectVersion创建流水线失败ERROR: Either the projectId or the projectName and projectVersion have to be specifiedissue\n\n\nDependency-Track Jenkins Plugin Handling of Project Deletion in DT Server\nAuto-Create Projects doesn’t work - 3.6.1 VersionprojectName and projectVersion are already properties that get saved. For freestyle builds, it forces the use of projectId and will only record that, but for pipeline jobs you get the option to specify either the projectId or the projectName + projectVersion.\n\nHowever, projectName + projectVersion currently doesn&#39;t support synchronous publishing mode due to API limitations in DT.\n\n\n解决问题10\n\n\n增加API token 权限：创建项目需要PROJECT_CREATION_UPLOAD权限，查看result结果需要VULNERABILITY_ANALYSIS和VIEW_VULNERABILITY等，建议可添加全部权限。\n\n\n进阶用法\n\n\n使用质量门阈值控制，同DC\nEnable synchronous publishing mode同步发布模式将BOM发布到DT并返回依赖跟踪处理的结果\nPublish Dependency-Check results公开依赖处理的结果\n使用pipeline处理：import hudson.model.*;\nimport hudson.*\nimport groovy.json.JsonSlurper;\n\npipeline &#123;\n    agent any\n\n    tools &#123;\n        &#x2F;&#x2F; maven &#39;maven&#39;\n        &#x2F;&#x2F;maven &#39;maven-apollo&#39;\n        maven maven\n        git &#39;Default&#39;\n        jdk &#39;jdk&#39;\n        &#x2F;&#x2F; nodejs &#39;node&#39;\n\n    &#125;\n         \n    stages &#123;\n        stage(&#39;删除上次构建&#39; )&#123;\n            steps &#123;\n               \n                sh &#39;rm -rf *&#39;\n                \n                wrap([$class: &#39;BuildUser&#39;]) &#123;\n                  \n                   script&#123;\n                       buildName &quot;#$&#123;projectName&#125;-$&#123;BRANCH&#125;-$&#123;env.BUILD_USER&#125;&quot;   \n\n                   &#125;\n                &#125;\n                \n            &#125;\n        &#125;\n        \n        stage(&#39;拉取代码&#39;)&#123;\n            steps &#123;\n                echo &#39;代码分支:&#39;+BRANCH\n                echo &#39;代码地址:&#39; +GIT_URL\n                git branch: BRANCH, credentialsId: &#39;0eeb53a0-0390-41a4-9ac2-8d4c4c5c884f&#39;, url: GIT_URL\n                \n            &#125;\n        &#125;\n\n       \n        stage(&#39;build&#39;) &#123;\n         steps &#123;\n                sh &#39;&#39;&#39;\n                    mvn clean install -e -U -DskipDockerPush -DdockerImageTags&#x3D;latest -Dmaven.test.skip&#x3D;true $mvn_params -f pom.xml\n                    \n                &#39;&#39;&#39;\n             &#125;\n         &#125;\n         \n        stage(&#39;Generating SBOM with Cyclonedx&#39;) &#123;\n            steps &#123;\n                sh &#39;mvn org.cyclonedx:cyclonedx-maven-plugin:makeAggregateBom&#39;\n            &#125;\n        &#125;\n        \n        stage(&#39;安全合规检查&#39;)&#123;\n            steps &#123;\n                script &#123;\n                    def jsonPayload &#x3D; new File(&quot;$WORKSPACE&#x2F;target&#x2F;bom.json&quot;).text\n                    def slurper &#x3D; new JsonSlurper()\n                    def states &#x3D; slurper.parseText(jsonPayload)\n                    def components &#x3D; states.components\n                    def checks &#x3D; [&#39;org.apache.shiro:shiro-spring&#39;:&#39;1.9.1&#39;]\n                    def fail_components &#x3D; &quot;&quot;\n                    for (component in components)&#123;\n                        def dep_name &#x3D; component.group + &quot;:&quot; + component.name\n                        \n                        if (dep_name in checks)&#123;\n                            current_version &#x3D; component.version\n                            \n                            check_version &#x3D; checks.get(dep_name)\n                            String[] current_version_chars &#x3D; current_version.split(&#39;\\\\.&#39;)\n                            String[] check_version_chars &#x3D; check_version.split(&#39;\\\\.&#39;)\n                            \n                            \n                            for(int i&#x3D;0; i&lt;current_version_chars.size(); i++)&#123;\n                                curr &#x3D; Integer.parseInt(current_version_chars[i])\n                                check &#x3D; Integer.parseInt(check_version_chars[i])\n                                if (curr &lt; check)&#123;\n                                    fail_components +&#x3D; component.group + &quot;:&quot; + component.name + &quot;版本过低，当前版本为：&quot; + component.version + &quot;，应不低于&quot; + check_version + &quot;\\n&quot;\n                                    break\n                                &#125;\n                            &#125;\n                        &#125;\n                        \n                    &#125;\n                    if(fail_components !&#x3D; &quot;&quot;)&#123;\n                        println(fail_components)\n                        error &quot;安全合规检查失败，请升级版本！！！&quot;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        \n        \n        stage(&#39;dependencyTrackPublisher&#39;) &#123;\n            steps &#123;\n                withCredentials([string(credentialsId: &#39;dt&#39;, variable: &#39;API_KEY&#39;)]) &#123;\n                    dependencyTrackPublisher artifact: &#39;target&#x2F;bom.xml&#39;, projectName: projectName, projectVersion: branch, \\\n                                            autoCreateProjects: true, dependencyTrackApiKey:API_KEY, synchronous: true, \\\n                                            failedNewCritical : 10000, failedNewHigh : 10000, failedNewLow: 10000, failedNewMedium: 10000, \\\n                                            failedTotalCritical : 10000, failedTotalHigh : 10000, failedTotalLow : 10000, failedTotalMedium : 10000,\n                                            unstableNewCritical : 10000, unstableNewHigh : 10000, unstableNewLow : 10000, unstableNewMedium : 10000,\\\n                                            unstableTotalCritical : 10000, unstableTotalHigh : 10000,unstableTotalLow : 10000, unstableTotalMedium : 10000\n                &#125;\n            &#125;\n        &#125;\n        \n    &#125;\n\n&#125;\n\n\n\n\nusageAnalyzers分析功能支持四种分析方式：\n\ninternal:默认开启，用于NVD和VulnDB的在线分析\nNPM Audit：默认开启，node.js的在线云服务\nSonatype OSS Index：默认关闭，需要配置：\nVulnDB：默认关闭，需要配置\n\nSonatype OSS Indexsonatype免费注册,注册后将注册邮箱和APItoken集成到deployment-track。sonatype支持上百万中组件的搜索，可以通过 REST API进行依赖扫描，同时sonatype还提供一款GitHub APP，Sonatype Lift · GitHub Marketplace · GitHub在每次来取请求时标记漏洞、在代码review时报告找的高风险issue。\nVulnDBVulnDB配置文档支持两种方式：\n\n通过VulnDB REST API进行分析API文档中未找到Consumer key 和Consumer secret，使用api key和用户名进行配置，可能存在问题。\n使用VULnDB 镜像数据库分析下载并安装VulnDB镜像GitHub - stevespringett&#x2F;vulndb-data-mirror: A simple Java command-line utility to mirror the entire contents of VulnDB.vulndb-data-mirror.sh \\\n    --consumer-key mykey \\\n    --consumer-secret mysecret \\\n    --dir &quot;~&#x2F;.dependency-track&#x2F;vulndb&quot;\n\n漏洞来源漏洞来源主要是：\n\nNVD：默认开启，在线feeds地址\nGithub Advisories:默认关闭，需要配置。GitHubPAT配置文档Creating a personal access token - GitHub Docs。\n\nRepositories默认不需要配置，添加了内部私仓Nexus Repository Manager\n通知添加webhook-slack添加webhook，但是没有消息提醒。template中的JSON格式不满足slack的消息格式。Creating rich message layouts | Slack\n添加mailAPI\ntrouble-shoutingsmtp![[2022-08-08_周一#DT 通知功能配置问题]]\n请求实例太大报错信息：\n[DependencyTrack] Publishing artifact to Dependency-Track - [http:&#x2F;&#x2F;dt-api.kubegems.io:32126](http:&#x2F;&#x2F;dt-api.kubegems.io:32126&#x2F;)\n[DependencyTrack] An error occurred connecting to Dependency-Track - HTTP response code: 413 Request Entity Too Large\n[DependencyTrack] &lt;html&gt;&lt;head&gt;&lt;title&gt;413 Request Entity Too Large&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;413 Request Entity Too Large&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.19.9&lt;&#x2F;center&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n修改路由配置，添加annotationAdvanced Configuration with Annotations | NGINX Ingress Controller\n# 默认1m 键值对\nnginx.org&#x2F;client-max-body-size 100m\n# anotations\n annotations:\n    nginx.org&#x2F;client-max-body-size: 100m\n\nIO阻塞\n\nQ:jenkins pipeline jobe push sbom.xml 2 dt timeout.\nA:分析日志apiserver-log。Jenkins job失败时间最早发生在17:18分钟，但是应用日志只有从17:36分开始记录的信息。初步分析可能是2022-09-06 17:53:58,790 ERROR [ServerRuntime$Responder] An I/O error has occurred while writing a response message entity to the container output stream.org.glassfish.jersey.server.internal.process.MappableException: org.eclipse.jetty.io.EofException既-短时间内大量的并发请求到APIserver的某些接口，接口处理超时导致资源耗尽引发阻塞。可能情况1：漏洞库更新任务占据了大量IO，通过日志分析：\n\nNistMirrorTask download 用时18710ms\nNistMirrorTask parse 用时5023970ms\nNistMirrorTask 总用时5062313ms（约1.4小时）\nGitHubAdvisoryMirrorTask总用时497066ms（约1.6分钟可忽略）可能情况2：push SBOM大量并发长请求，导致APIserver网络阻塞、I&#x2F;O过载\nJenkins 对接DT用到了put方法publishing SBOM，\njenkins使用Enable synchronous publishing mode同步发布模式将BOM发布到DT并返回依赖跟踪处理的结果，可能在NistMirrorTask GitHubAdvisoryMirrorTask  MetricsUpdateTask后同步更新信息A:解决思路\n 申请服务器部署war包的方式部署（以及集群部署？）\n 更换MySQL数据库\n 现有K8S容器环境中设置时区，设置漏洞库更新时间，扩容副本 ✅ 2022-09-07 添加key:TZ value:Asia&#x2F;Shanghai\n 提个issue ✅ 2022-09-07\n 修改Jenkinstimeout参数\n\nQ：otherERROR [LoggableUncaughtExceptionHandler] An unknown error occurred in an asynchronous event or notification thread · Issue #1059 · DependencyTrack&#x2F;dependency-track · GitHub近1周资源监控信息重启pod后的资源监控信息重启后的日志\nReferencesGitHub - AppThreat&#x2F;cdxgen: Creates CycloneDX Software Bill-of-Materials (SBOM) for your projects from source and container images. Supports many languages and package managers. Integrate in your CI&#x2F;&#x2F;CD pipeline with automatic submission to Dependency Track server.GitHub - CycloneDX&#x2F;cyclonedx-cli: CycloneDX CLI tool for SBOM analysis, merging, diffs and format conversions.Site Unreachable深度解读 |《构建软件组件透明度：建立通用的软件物料清单（SBOM）》（上）OWASP Dependency-Track | Jenkins plugin使用Jenkins新建并配置一个本地项目Jenkins持续集成demoGitHub | Jenkins pluginOWASP Dependency-Track Plugin基于开源工具实现软件成分分析SCA - 先知社区基于 Dependency-Track 构建免费的第三方组件安全管理平台 - 安全客，安全资讯平台\n","slug":"dependency-track","date":"2022-06-23T09:38:36.281Z","categories_index":"","tags_index":"SCA,部署手册,SBOM,OWASP,dependency-track,软件供应链","author_index":"Moses"},{"id":"520e1d6d52856a91475d0b89567aa470","title":"软件供应链安全分析工具-Dependency-Check","content":"dependency-check0x01简介Dependency-Check是OWASP（Open Web Application Security Project）的一个实用开源程序，用于识别项目依赖项并检查是否存在任何已知的，公开披露的漏洞。目前，已支持Java、.NET、Ruby、PHP、Node.js、Python等语言编写的程序，并为C&#x2F;C++构建系统（autoconf和cmake）提供了有限的支持。而且该工具还是OWASP Top 10的解决方案的一部分。\nDependency-Check支持面广（支持多种语言）、可集成性强，作为一款开源工具，在多年来的发展中已经支持和许多主流的软件进行集成，比如：命令行、Ant、Maven、Gradle、Jenkins、Sonar等；具备使用方便，落地简单等优势。\n\n项目地址\n官网\nDocs\n\nDependency Check有三种使用方式：\n从命令行使用：此时Dependency Check作为一个单独的软件，与项目无关，使用时只需指定需要扫描的项目位置即可。在业务上线流程中推荐使用此方式  \n作为插件在项目中使用：此时需要在项目的配置文件中做相关内容添加，只对当前项目有效。别的项目需要使用时，需要重新修改配置文件  \n作为Ant Task使用：这种方式的使用介于以上两者之间，可以在多个项目中使用，但是需要安装，并且需要在项目的build.xml中添加相关配置。\n\n0x02实现原理依赖性检查可用于扫描应用程序（及其依赖库），执行检查时会将 Common Platform Enumeration (CPE)美帝国家漏洞数据库及NPM Public Advisories库下载到本地，再通过核心引擎中的一系列分析器检查项目依赖性，收集有关依赖项的信息，然后根据收集的依赖项信息与本地的CPE&amp;NPM库数据进行对比，如果检查发现扫描的组件存在已知的易受攻击的漏洞则标识，最后生成报告进行展示。\n依赖项检查的工作原理是收集有关其扫描的文件的信息（使用分析器）。收集的信息称为证据；收集的证据有三种类型：供应商、产品和版本。例如，JarAnalyzer将从清单、pom.xml和扫描的JAR文件中的软件包名称中收集信息，并具有启发式方法将来自各种来源的信息放入一个或多个证据桶中。在NVD CVE数据（模式可以在这里找到）中，每个CVE条目都有一个易受攻击的软件列表：\n&lt;entry id&#x3D;&quot;CVE-2012-5055&quot;&gt;\n  ...\n    &lt;vuln:vulnerable-software-list&gt;\n      &lt;vuln:product&gt;cpe:&#x2F;a:vmware:springsource_spring_security:3.1.2&lt;&#x2F;vuln:product&gt;\n      &lt;vuln:product&gt;cpe:&#x2F;a:vmware:springsource_spring_security:2.0.4&lt;&#x2F;vuln:product&gt;\n      &lt;vuln:product&gt;cpe:&#x2F;a:vmware:springsource_spring_security:3.0.1&lt;&#x2F;vuln:product&gt;\n    &lt;&#x2F;vuln:vulnerable-software-list&gt;\n  ...\n  &lt;&#x2F;entry&gt;\n在NVD CVE数据库中，每个CVE条目都有一个易受攻击的软件列表。这些CPE条目记录了“CPE:&#x2F;入口类型:供应商:产品:版本:修订:…”这些属性。这些数据被收集并存储在Lucene索引中。然后使用所收集的证据，并尝试匹配Lucene CPE索引中的条目。如果找到，CPEAnalyzer分析器将向依赖项添加标识符，并随后添加到报告中。一旦确定了CPE，就将关联的CVE条目添加到报告中。这些证据在写入报告的时候会被分级使用不同的信心级别——低、中、高和最高。它等于在识别过程中使用的证据的最低水平的信心水平。如果用于识别某个CPE的一系列证据中信心等级最低的证据是高级，那么，那么CPE将拥有高级的信心水平。\n0x03Quickstartmacbrew update &amp;&amp; brew install dependency-check\n下载安装 GitHub Release\n编译安装-略usage命令行使用Command Line Argumentsdependency-check –advancedHelp包括使用本地数据库、制成品库扫描等\n支持的文件dependency-check – File Type Analyzersdependency-check支持多种格式的文件：Zip archive format (*.zip, *.ear, *.war, *.jar, *.sar, .apk, .nupkg); Tape Archive Format (.tar); Gzip format (.gz, .tgz); Bzip2 format (.bz2, *.tbz2)。\n示例第一次使用,需要下载漏洞库\n 生成扫描报告: Dependency-check支持多种输出格式，默认是HTML格式。在命令式方式使用时，指定参数–format来选定格式，可以有XML, HTML, CSV, JSON, VULN, ALL这些选项（必须是大写）。                                                               \n扫描结果对比 [[OpenSCA#测试对比]]\n插件使用\nMaven: mvn -version 3.5.0 and higher\nMaven命令方式:\nmvn org.owasp:dependency-check-maven:check\n查询某一个依赖 mvn dependency:list|grep -i &quot;log4j*&quot;\nmvn dependency:tree\n聚合查询 mvn clean org.owasp:dependency-check-maven:aggregate -Dformat=HTML\n需要在maven的项目依赖你添加dependency-check的依赖如下： &lt;project&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            ...\n            &lt;plugin&gt;\n              &lt;groupId&gt;org.owasp&lt;&#x2F;groupId&gt;\n              &lt;artifactId&gt;dependency-check-maven&lt;&#x2F;artifactId&gt;\n              &lt;executions&gt;\n                  &lt;execution&gt;\n                      &lt;goals&gt;\n                          &lt;goal&gt;check&lt;&#x2F;goal&gt;\n                      &lt;&#x2F;goals&gt;\n                  &lt;&#x2F;execution&gt;\n              &lt;&#x2F;executions&gt;\n            &lt;&#x2F;plugin&gt;\n            ...\n        &lt;&#x2F;plugins&gt;\n        ...\n    &lt;&#x2F;build&gt;\n    ...\n&lt;&#x2F;project&gt;\n\nant使用 略 dependency-check-ant – Configuration\n0x04 漏洞库本地安装后，会缓存NVD数据库，主要是两个文件jsrepository.json和odc.mv.db\n搭建本地NVD Mirror库需求\n企业中内网环境可能CI服务器不会开放对外网的访问权限，需要搭建一个本地的NVDMirror\n需要二次开发\n\n手动搭建nvd官方提供了对应jar包来作为mirror的服务GitHub - stevespringett&#x2F;nist-data-mirror: A simple Java command-line utility to mirror the CVE JSON data from NIST.\n\n下载release jar包Site Unreachable\n执行java -jar nist-data-mirror.jar\n搭建Apache服务\n定时任务更新jsreponsitory.jsondependency-check – Snapshotting the NVD\n客户端使用设置参数如下--cveUrlModified http:&#x2F;&#x2F;你的本地服务器:30006&#x2F;nvdcve-1.1-modified.json.gz\n--cveUrlBase http:&#x2F;&#x2F;你的本地服务器:30006&#x2F;nvdcve-1.1-modified.json.gz\njenkins pipeline修复mirror地址dependencyCheck additionalArguments: &#39;--cveUrlModified http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;nvdcve-1.1-2019.json.gz --cveUrlBase http:&#x2F;&#x2F;x.x.x.x:8080&#x2F;nvdcve-1.1-2019.json.gz &#39;, odcInstallation: &#39;dependency-check&#39;\n\ndocker搭建$ mvn clean package\n$ docker build --rm -t sspringett&#x2F;nvdmirror .\n$ mkdir target&#x2F;docs\n$ docker run -dit \\\n  --name mirror \\\n  -p 80:80 \\\n  --mount type&#x3D;bind,source&#x3D;&quot;$(pwd)&quot;&#x2F;target&#x2F;docs&#x2F;,target&#x3D;&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs \\\n  sspringett&#x2F;nvdmirror\n\nk8s部署# 打包，**需要chartmusuem**\n# cd to charts directory\n$ cd nist-data-mirror\n\n# Create directory for package\n$ mkdir .&#x2F;target\n\n# Package helm chart\n$ helm package --app-version &lt;app_version&gt;  --version &lt;helm_chart_version&gt; -destination .&#x2F;target .\n\n# As a best practice, push your packaged chart to helm repo. e.g. push it to artifactory, chartmusuem etc.\n$ helm push target&#x2F;nist-data-mirror-&lt;helm_chart_version&gt;.tgz chartmuseum\n# 部署\n# helm install --name &lt;release_name&gt; &lt;helm_repo&gt;&#x2F;&lt;chart_name&gt;\n$ helm install --name nist-data-mirror chartmuseum&#x2F;nist-data-mirror\n\nMysql 存储nvd 数据目前支持的数据库包括：h2、mysql、oracle、sql server、postgresQL。以MySQL为例：1.创建MySQL数据库2.初始化数据库，脚本-&gt;DependencyCheck&#x2F;core&#x2F;src&#x2F;main&#x2F;resources&#x2F;data at main · jeremylong&#x2F;DependencyCheck · GitHub3.将对应的MySQL数据库驱动拷贝到dependency-check-7.1.0-release\\dependency-check\\lib的目录中4.执行命令dependency-check -s biz-service-0-1.0.0.jar --dbDriverName r --connectionString jdbc:mysql://127.0.0.1:3306/dependencycheck --dbUser dcuser --propertyfile dependencycheck.properties暂时没有需要未实际搭建\n# 初始账号密码\ndata.user&#x3D;dcuser\ndata.password&#x3D;DC-Pass1337!\nCI&#x2F;CD集成Jenkins-未测试Jenkins没有权限\n安装OWASP Dependency-Check插件\n\n全局工具配置下配置dependency插件路径及版本（可单独下载）自动安装未成功，可以手动下载\nwget https:&#x2F;&#x2F;github.com&#x2F;jeremylong&#x2F;DependencyCheck&#x2F;releases&#x2F;download&#x2F;v7.1.1&#x2F;dependency-check-7.1.1-release.zip\n全局工具配置，设置Dendency-Check 别名 安装路径\n\nfreestyle项目在构建步骤选择‘增加构建步骤’，选择‘Dependency_check’或者使用**###  execute shell**\nsh &#x2F;home&#x2F;dc&#x2F;dependency-check&#x2F;bin&#x2F;dependency-check.sh -s $&#123;WORKSPACE&#125;&#x2F; --format HTML --format XML  -o .&#x2F;\npipeline流水线中执行dependency-check安全扫描\nsh &#39;&#x2F;data&#x2F;jenkins&#x2F;tools&#x2F;org.jenkinsci.plugins.DependencyCheck.tools.DependencyCheckInstallation&#x2F;dependency-check&#x2F;bin&#x2F;dependency-check.sh -s PWD&#x2F;dependency-check-report.xml’\nsh &#39;&#x2F;data&#x2F;jenkins&#x2F;tools&#x2F;org.jenkinsci.plugins.DependencyCheck.tools.DependencyCheckInstallation&#x2F;dependency-check&#x2F;bin&#x2F;dependency-check.sh -s PWD&#x2F;dependency-check-report.html\n使用Jenkins发布XML和HTML报告\n\n设置风险门禁，设置允许的严重、高、中或低严重性发现总数的阈值。如果发现的数量等于或大于任何一个严重性的阈值，则作业状态将更改为不稳定或失败。也可以设置对新发现的检测结果设置阈值。\n\n最终效果\n\n查看结果汇总\n\nhtml报告解析\nfrom bs4 import BeautifulSoup\nfrom lxml import etree\n\nclass GetSecRes:\n    \n    def get_dependency_critical_num_with_lxml(self, filename):\n        &#39;&#39;&#39;\n        用lxml库解析安全扫描的html报告，并统计出其中的critical的漏洞数量\n        :param filename: dependency-check扫描完成后生产的html文件，文件名全路径\n        :return:critical数量\n        &#39;&#39;&#39;\n        # 读取html文件\n        with open(filename, encoding&#x3D;&#39;utf-8&#39;) as f:\n            data &#x3D; f.read()\n        doc &#x3D; etree.HTML(data)\n        # 获取漏洞汇总表中的漏洞行信息\n        trs &#x3D; doc.xpath(&#39;&#x2F;&#x2F;*[@id&#x3D;&quot;summaryTable&quot;]&#x2F;&#x2F;tr[@class&#x3D;&quot; vulnerable&quot;]&#39;)\n        criticalres &#x3D; []\n        # 统计出每行的critical数量\n        for tr in trs:\n            tr_list &#x3D; tr.xpath(&#39;.&#x2F;td&#x2F;@data-sort-value&#39;)\n            td_text &#x3D; tr.xpath(&#39;.&#x2F;td&#x2F;text()&#39;)\n            tr_list.extend(td_text)\n            [criticalres.append(td) for td in tr_list if &quot;CRITICAL&quot; &#x3D;&#x3D; td]\n        return (len(criticalres))\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    import sys\n    filename &#x3D; sys.argv[1]\n    criticalres &#x3D; GetSecRes().get_dependency_critical_num_with_lxml(filename)\n    print(”严重组件数量“,criticalres)\n\n\n集成脚本到jenkins的execute shell中\ncritical&#x3D;$(python3 &#x2F;home&#x2F;get-security-result.py $&#123;DIR&#125;&#x2F;dependency-check-report.html)  \necho $critical\n\nSonarqube-未测试没有权限1.下载对应sonarqube版本的jar包插件GitHub - dependency-check&#x2F;dependency-check-sonar-plugin: Integrates Dependency-Check reports into SonarQube2.上传到%SONAR_HOME%&#x2F;extensions&#x2F;plugins目录下3.重启sonarqube4.jenkins流水线中执行sonar扫描\nReferences\njar第三方组件Dependency-check依赖检查工具|棉花哥的博客|Cotton’s Blog\n使用OWASP Dependency-Check进行第三方依赖包安全扫描实践 | 码农家园\n「干货」Dependency check配置Mysql数据库存储nvd数据_科技通讯_闲暇巴\nSonarQube集成DependencyCheck - Open-Source Security Architecture\nOWASP Dependency-Check | Jenkins plugin\n【安全测试】Owasp Dependency-check 集成jenkins - 码上起舞 - 博客园\nDependency-Check部署及Jenkins集成OWASP Dependency-Check Plugin_我在北国不背锅的博客-CSDN博客_jenkins owasp\n\n","slug":"dependency-check","date":"2022-06-22T05:45:00.000Z","categories_index":"","tags_index":"owasp,dependency-check,SCA,软件供应链安全,部署手册","author_index":"Moses"},{"id":"e996202d66a481abb2ff37739071b61f","title":"SCA软件成分分析前期探索","content":"SCA软件成分分析前期探索概述和背景SCA概念SCA(Software Composition Analysis)软件成分分析技术主要就是针对开源软件以及第三方商业软件设计的各种源码、源码库、模块和框架，识别和清点开源软件的组件及其构成和依赖关系，并识别已知的安全漏洞或潜在的许可授权问题，争取在应用系统上线前发现并解决这些风险。它有助于确保企业软件供应链仅包含安全的组件，从而支持安全应用程序开发和组装。\nSCA需求\n支持多种语言的深度扫描能力\n具备CI&#x2F;CD集成自动化能力，并且将其扫描结果作为交付质量关卡、保证软件交付质量\n具备可视化漏洞分析报表和license报表，以可视化漏洞的监管能力和可视化企业使用license的情况\n拥有对开源漏洞数据库、商业漏洞数据库、本地漏洞数据中心和其他漏洞扫描工具的集成能力，通过不同的漏洞数源丰富SCA工具对第三方安全漏洞的判断能力\n能够进行正向依赖分析从而定位漏洞位置，以及进行反向依赖分析自动化地分析漏洞的影响范围\n自定义告警配置、通知和自动化能力，以提供企业漏洞的快速响应能力\n\n漏洞数据库google 开源洞见Open Source Insights是谷歌的一项实验项目，由Google 云平台提供。提供npm、Maven、PyPi、NuGut、Go等语言的开源软件包查询。查询结果包括项目信息：\n\n项目描述\nlink连接\nrepo\nhomepage\norgin\n\n\n版本信息\n开源协议\n事件历史项目安全信息：\n安全公告\n版本比较\nDependents\nDependencies\n\n\n同时，提供公共数据集，可以使用BigQuery查询分析使用，当然如果不考虑网络的问题也可以使用Grafana搭建分析视图Grafana的bigquery插件类似Linux开源基金会曾经的一个项目metrics进阶-&gt;:谷歌 bigquery 配置代理\nbigquery-public-data.deps_dev_v1.ProjectsThe type of the project, example values include ‘APACHE_JIRA’, ‘BITBUCKET’, ‘GITHUB’ and ‘GITLAB’.\nbigquery-public-data.deps_dev_v1.PackageVersions\nbigquery-public-data.deps_dev_v1.Dependencies\nbigquery-public-data.deps_dev_v1.Advisories\nlicense查询查询结果\n&#123; &quot;System&quot;: &quot;CARGO&quot;, &quot;License&quot;: &quot;MIT&quot;, &quot;NPackages&quot;: &quot;36775&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;CARGO&quot;, &quot;License&quot;: &quot;Apache-2.0 OR MIT&quot;, &quot;NPackages&quot;: &quot;22671&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;CARGO&quot;, &quot;License&quot;: &quot;Apache-2.0&quot;, &quot;NPackages&quot;: &quot;9958&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;GO&quot;, &quot;License&quot;: &quot;MIT&quot;, &quot;NPackages&quot;: &quot;216790&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;GO&quot;, &quot;License&quot;: &quot;Apache-2.0&quot;, &quot;NPackages&quot;: &quot;108678&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;GO&quot;, &quot;License&quot;: &quot;BSD-3-Clause&quot;, &quot;NPackages&quot;: &quot;28823&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;MAVEN&quot;, &quot;License&quot;: &quot;Apache-2.0&quot;, &quot;NPackages&quot;: &quot;263361&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;MAVEN&quot;, &quot;License&quot;: &quot;MIT&quot;, &quot;NPackages&quot;: &quot;75302&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;MAVEN&quot;, &quot;License&quot;: &quot;non-standard&quot;, &quot;NPackages&quot;: &quot;68080&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;NPM&quot;, &quot;License&quot;: &quot;MIT&quot;, &quot;NPackages&quot;: &quot;3229651&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;NPM&quot;, &quot;License&quot;: &quot;ISC&quot;, &quot;NPackages&quot;: &quot;1003365&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;NPM&quot;, &quot;License&quot;: &quot;Apache-2.0&quot;, &quot;NPackages&quot;: &quot;235446&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;PYPI&quot;, &quot;License&quot;: &quot;MIT&quot;, &quot;NPackages&quot;: &quot;105168&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;PYPI&quot;, &quot;License&quot;: &quot;non-standard&quot;, &quot;NPackages&quot;: &quot;50207&quot;&#125;\n\n&#123; &quot;System&quot;: &quot;PYPI&quot;, &quot;License&quot;: &quot;Apache-2.0&quot;, &quot;NPackages&quot;: &quot;22749&quot;&#125;\nCPE开放数据CPECPE（Common Platform Enumeration，CPE国家漏洞数据库）数据库是一个包含产品、其版本、供应商等信息的列表。要实现SCA，必须获得CPE和CVE的通信信息。\nCPE和CVE数据-API在官方网站国家脆弱性数据库上找到CPE数据库和CVE合规性。获取必要信息的方法之一是使用Rest API。这里描述了它。例如，以下查询允许我们获取CPE数据库的前20个元素，包括相应的CVE：测试以下是ActivePerl的CPE示例：\n&#123; &quot;deprecated&quot;: false, &quot;cpe23Uri&quot;: &quot;cpe:2.3:a:activestate:activeperl:-:*:*:*:*:*:*:*&quot;, &quot;lastModifiedDate&quot;: &quot;2007-09-14T17:36Z&quot;, &quot;titles&quot;: [ &#123; &quot;title&quot;: &quot;ActiveState ActivePerl&quot;, &quot;lang&quot;: &quot;en_US&quot; &#125; ], &quot;refs&quot;: [], &quot;deprecatedBy&quot;: [], &quot;vulnerabilities&quot;: [ &quot;CVE-2001-0815&quot;, &quot;CVE-2004-0377&quot; ] &#125;\n这里最重要的部分是“cpe23Uri”值。它以某种格式为我们提供了重要信息，当然还有“漏洞”（尽管它们不是CPE列表的一部分）。为了简单起见，我们将“cpe23Uri”字符串读作\ncpe:2.3:a:&lt;vendor&gt;:&lt;product&gt;:&lt;version&gt;:&lt;update&gt;:...\n根据规范，代替其中一个片段的连字符意味着逻辑“NA”值。这可以解释为“值未设置”。代替片段的“*”字符意味着“任何”。\n当我们实现基于CPE的解决方案时，主要困难是为每个依赖项找到正确的元素。这里的问题是，库名称（在我们解析项目链接时获得）可能与相应的CPE条目不匹配。例如，CPE列表有以下“cpe23Uri”的条目：\ncpe:2.3:a:microsoft:asp.net_model_view_controller:2.0:*:*:*:*:*:*:* cpe:2.3:a:microsoft:asp.net_model_view_controller:3.0:*:*:*:*:*:*:* cpe:2.3:a:microsoft:asp.net_model_view_controller:4.0:*:*:*:*:*:*:* cpe:2.3:a:microsoft:asp.net_model_view_controller:5.0:*:*:*:*:*:*:* cpe:2.3:a:microsoft:asp.net_model_view_controller:5.1:*:*:*:*:*:*:*\n\n\n\n\n\n\n\n\n\n要检测 jar 包存在的漏洞，首先要有准确且足够全的漏洞库，最好能够契合 maven 坐标。NVD 漏洞最全，但以 cpe 格式标识漏洞的影响软件，使得建立 cpe 和 maven 坐标的对应关系比较麻烦。 DependencyCheck(https://github.com/jeremylong/DependencyCheck) 基于 NVD 漏洞库通过计算相似度来关联依赖和 cpe，不可避免的会存在误报和漏报。\nCPE和CVE数据-数据源数据源NVD - Data Feeds\n\nCPE: https://nvd.nist.gov/feeds/xml/cpe/dictionary/official-cpe-dictionary_v2.3.xml.gz\nCWE: https://cwe.mitre.org/data/xml/cwec_latest.xml.zip\nCVE:\nhttps://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-2021.json.gz\nhttps://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-2020.json.gz\nhttps://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-2019.json.gz\n[…]\nhttps://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-2002.json.gz\n\n\n\nAPI和数据源类型名词解释\n\n1.漏洞库：即漏洞数据库，主要是只大型的、公开的、业界公认的漏洞数据库。比如NVD、CNVD、exploit-db等。\n2.CVE ：即为每个漏洞确定了唯一的名称，通过它能帮助安全从业人员快速地在漏洞数据库中找到相应的漏洞信息。\n3.CPE ：即漏洞所关联的产品、版本、依赖路径或命名规范等信息，通过此信息，可以知道某个CVE所影响的组件版本和所在产品的依赖路径。\n4.CWE ：即漏洞的类型，比如某3个组件都存在SQL注入漏洞，这3个漏洞的CVE并不相同，但CWE都可描述为CWE-89 SQL注入类型的漏洞。\n5.CVSS ：即通用漏洞评分系统，通过对漏洞进行评分，来定义威胁的高、中、低以便区别，辅助制定漏洞修复策略。\n\n\n\n\n类型\n描述\n\n\n\nCVE和CPE API\n传统漏洞数据提要文件的替代品。与JSON漏洞提要和CPE匹配提要相比，API要灵活得多，在单个界面中提供了更丰富的数据集。\n\n\nJSON脆弱性信息\n文件中的每个漏洞都包括来自CVE®词典提要的描述和相关参考链接，以及CVSS基本分数、易受攻击的产品配置和弱点分类。\n\n\nCPE比赛Feed\n根据官方CPE词典中的CPE匹配提供产品&#x2F;平台适用性声明到CPE URI匹配的提要。\n\n\nRSS漏洞Feed\n八天的安全相关软件缺陷窗口。\n\n\n漏洞翻译Feed\n漏洞提要的翻译。\n\n\n漏洞供应商评论\n供应商就影响产品内部的特定缺陷提供的评论。\n\n\nCPE词典\n包含产品列表的词典。\n\n\n通用配置枚举（CCE）参考数据\n常见配置项的参考数据。\n\n\n使用GitHub安全公告advisoryGitHub Advisory是在存储在GitHub上的开源项目中发现的漏洞数据库（CVE）。GitHub Advisory比CPE方便得多，[[SCA软件成分分析前期探索#google 开源洞见]]也使用该数据库。Google开源软件洞见数据库导出的500条advisory如下：\n要以编程方式访问GitHub Advisory，我们需要使用GraphQL API查询。Explorer - GitHub Docs\nsnyk 开源漏洞库Snyk Vulnerability Database | Snyk开源数据可以进行漏洞及开源软件查询,支持各种包管理器如Linux、maven、NPM等。该漏洞库以 groupId:artifactId 作为软件名称，以版本区间的方式表示影响范围，SCA 在检测漏洞时，仅需要从 mavenTree 中取出 jar 包版本与漏洞库中的版本区间作比较即可Snyk API · ApiaryAPI接口支持REST接口调用，📢API需要商业付费的用户或组织才能够使用，免费个人用户无权访问API付费计划\n开源第三方安全扫描工具SCASonatypeSoftware Supply Chain Security - DevSecOps Governance | SonatypeMaven Central Repository SearchSonatype OSS IndexREST API - The Central Repository Documentation\nOWASP Dependency-CheckOWASP Dependency-Check是一个用于扫描项目依赖项的SCA实用程序，用于识别项目依赖项并检查是否存在任何已知的、公开披露的漏洞；目前已支持Java、Ruby、.NET、NodeJs、Ruby、Python等语言编写的程序。并为C&#x2F;C++构建系统（autoconf和cmake）提供了有限的支持；另外，作为一款开源工具，在多年来的发展过程中已经支持与许多主流软件进行集成，比如Jenkins等；具备使用方便、落地简单等优势。Dependency-Check的依赖性检查可用于应用程序（及依赖库），执行检查时会将Common Platform Enumeration（CPE）国家漏洞库及NPM Public Advisories库下载到本地，再通过核心引擎中的一系列分析器检查项目依赖性，收集有关依赖项目的信息，然后根据收集的依赖项信息与本地的CPE&amp;NPM库数据进行对比，如果检查发现扫描的组件存在已知的易受攻击和漏洞则标识，最后生成报告进行展示。\n\n👑项目地址GitHub - jeremylong&#x2F;DependencyCheck: OWASP dependency-check is a software composition analysis utility that detects publicly disclosed vulnerabilities in application dependencies.\n👁WIKIHome · jeremylong&#x2F;DependencyCheck Wiki · GitHub\n📒Docsdependency-check – About[[dependency-check]]\n\nOWASP Dependency-TrackOWASP Dependency-Track是一个组件分析平台，Dependency-Track是OWASP推出的一个智能供应链组件分析平台，它集成了4种漏洞数据库：NPM Public Advisories、National Vulnerability Database、Sonartype OSS Index和VulnDB，相比于其他开源检测工具单一的漏洞库，Dependency Track出现漏报或者误报的情况会小很多。同时它提供了强大的API集成功能（如openAPI和Jenkins的插件），在开发安全建设过程中我们可以将其整合到我们的pipeline中帮助DevOps团队提高开发流程速度，同时还能控制外部组件的使用和它们可能造成的风险。此外通过maven收集仓库中所有依赖包的信息，记录各个开发团队的应用程序所使用的各种第三方依赖信息，以便进行依赖包管理（版本控制、漏洞管理等）。在开发过程中可以基于soner bug追踪的组件安全跟踪，甚至fortify这样的代码白盒review介入，并通过邮件、钉钉告警通知安全团队、开发团队。👑官网\n核心架构\n检测原理Dependency Track通过接收到生成的Software BOM(软件物料清单)[[软件物料清单SBOM]]，然后检查物料清单中的各个组件(以及当前清单中的版本)在漏洞数据库中是否存在已知安全漏洞的记录，并通过Dashboard展示出来。所以你需要先准备好一份SBOM清单，然后发送给Dependency Track，等待它完成扫描检测之后，然后在管理界面上查看结果。\n\n\n\n\n\n\n\n\n\nSBOM（Software Bill of Material）翻译之后称为软件物料清单。通俗的解释就是我们用到的所有第三方组件依赖（包括第三方组件自己所依赖的其他第三方组件，换句话讲，依赖的依赖）的信息清单，这些内容包括author、group, licenses, versions and copyright等数据。\n\n\n\n字段\nSPDX值\nSWID值\n\n\n\n供应商\n（3.5） PackageSupplier:\n @role (softwareCreator&#x2F;publisher),@name\n\n\n组件\n（3.1）PackageName:\n @name\n\n\n唯一标识\n（3.2）SPDXID:\n @tagID\n\n\n版本\n（3.3）PackageVersion:\n @version\n\n\n组件散列值\n（3.10）PackageChecksum:\n&#x2F;..&#x2F;@[hash-algorithm]:hash\n\n\n相互关系\n（7.1）Relationship:CONTAINS\n@rel,@href\n\n\nSBOM编辑人\n（2.8）Creator:\n @role (tagCreator),@name\n\n\n生成SBOM的工具有几个，其中比较有名的是CycloneDXOWASP CycloneDX Software Bill of Materials (SBOM) Standard是一个轻量级软件材料清单（SBOM）标准。一旦我们有了BOM文件，我们就可以手动或通过整合CI&#x2F;CD中的上传功能将其上传到Dependency-Track。Dependency track相当于一个漏洞库和分析引擎，它基于SBOM，在漏洞库中搜索，这样我们就可以获得比传统组件分析更完整、更复杂的信息。\nDependency Track VS Dependency check\nDependencyCheck更多是给开发团队使用的工具\nDependencyTrack更多的是给安全团队使用的工具\n企业或者组织中的安全团队可以借助DependencyTrack实现第三方组件的统一安全管理\nDependencyCheck只能对第三方组件做安全检测并生成报告，仅此而已\nDependencyTrack会保存历次第三方组件安全检测结果，你可以通过Dashboard了解或者追踪第三方组件的安全变化趋势\nDependencyTrack还提供了很多额外的功能，例如漏洞通知、全局审查第三方组件、审计第三方组件软件授权协议、API等等\n\n部署DependencyCheck支持3种部署方式，分别是容器化部署、自运行安装包，以及可以直接在Tomcat里运行的WebApp包。docker部署\n# 下载DependencyTrack镜像\n\ndocker pull owasp&#x2F;dependency-track\n\n# 创建并使用宿主机上的存储以避免数据丢失\ndocker volume create --name dependency-track\n\n# 在8080端口上运行DependencyTrack，默认账户密码admin&#x2F;admin\ndocker run -d -m 8192m -p 8080:8080 --name dependency-track -v dependency-track:&#x2F;data owasp&#x2F;dependency-track\n更换数据库（可选）\n# 1.根路径新建dependency-track目录，然后在该目录下新建application.properties文件，在文件中填写下面配置\n\nalpine.database.mode&#x3D;external\n\nalpine.database.url&#x3D;jdbc:postgresql:&#x2F;&#x2F;localhost:5432&#x2F;dtrack\n\nalpine.database.driver&#x3D;org.postgresql.Driver\n\nalpine.database.username&#x3D;dtrack\n\nalpine.database.password&#x3D;password\n\n# 2.使用命令docker-compose up重新启动一下，配置就生效了，启动时间可能略长。参考：https:&#x2F;&#x2F;docs.dependencytrack.org&#x2F;getting-started&#x2F;database-support&#x2F;\n卸载\ndocker rmi owasp&#x2F;dependency-track\n\ndocker rm dependency-track\n\ndocker volume rm dependency-track:&#x2F;data\n\t\nOpenSCA[[OpenSCA]]\n商业产品\t\n    \n\n\nCloudDefenseSCA - Software Composition Analysis\nVeraCodeSCA to Automate Security Scanning | Veracode\nSnkySnyk | Developer security | Develop fast. Stay secure.\nSynopsys-blackduckBlack Duck Software Composition Analysis (SCA) | Synopsys\nMendOpen Source Vulnerability Database | Mend\n最佳借鉴VIVO引入前检测第三方组件在引入阶段时，vivo千镜安全实验室会采用静态分析、动态自动分析和手工调试等多种方式，对第三方组件进行深度的安全和隐私评估，保障第三方组件不会存在侵害用户权益的行为。\n开源组件在引入阶段时，vivo千镜安全实验室通过构建开源组件风险知识库，将引入组件与风险知识库进行匹配，从License、安全、合规等多维度生成开源组件引入报告。\n引入后扫描由于vivo的应用程序众多，如果对所有代码仓及分支进行人工审查，无疑会消耗巨大的人力。因此，vivo千镜安全实验室开发了软件成分分析引擎，其中包含正向扫描与逆向检测两个子引擎。软件成分分析引擎通过CI集成自动化触发代码仓扫描，实现自动化分析检测。同时，通过风险管控流程触发风险处理流程，将扫描结果通知到各负责人，从而确保第三方组件的应用安全和开源组件的使用合规。\n正向扫描正向扫描引擎又称为源码扫描引擎，主要通过扫描代码仓的方式对各应用程序进行软件成分分析，进而扫描出应用程序所集成的第三方组件及开源组件。\n在进行正向扫描之前，需要对应用程序的资产以及第三方组件和开源组件的特征进行收集。应用程序的资产包括代码仓、负责人等信息；第三方和开源组件的特征主要包括开发商、负责人、版本、文件HASH等信息。\n正向扫描引擎包括gradle文件扫描、工程文件扫描以及代码片段扫描：\n\nGradle文件扫描指通过解析工程中gradle文件，获取通过gradle引入的第三方组件和开源组件；\n\n工程文件扫描指通过扫描工程中jar包或aar包，获取通过本地集成引入的第三方组件和开源组件；\n\n代码片段扫描指通过扫描源代码，将源代码中代码片段与开源组件的知识库进行比对，获取代码引入的开源组件。\n\n\n值得一提的是，正向扫描引擎能够检测出应用程序引入的第三方组件和开源组件的版本信息。当第三方组件和开源组件披露出安全漏洞时，能够通过正向扫描即时检测出引用问题组件的应用程序信息，从而提高安全响应效率。\t\n逆向检测逆向检测引擎主要通过对应用程序的反汇编路径使用特征指纹匹配的方式进行软件成分分析，进而扫描出应用程序所集成的第三方组件及开源组件。\n在进行逆向检测之前，需要对第三方组件和开源组件的特征进行收集。由于逆向扫描主要对应用程序的反汇编代码进行扫描，因此需要将加固的应用进行脱壳预处理。\n逆向扫描引擎对APK进行反汇编后，将反汇编的代码与组件的特征指纹进行匹配，从而得到扫描结果。\t\nReferences\n👑OWASP Top Ten and Software Composition Analysis (SCA)\nSecurity Content Automation Protocol | CSRC\n58安全应急响应中心|Java 供应链(依赖)安全检测实践\nAPI Products\nAPI Vulnerabilities\nGartner:SCA市场指南Site Unreachable\n软件成分分析（SCA）完全指南_开源_SEAL软件供应链安全_InfoQ写作社区\nGitHub - dependabot&#x2F;dependabot-core: 🤖 The core logic behind Dependabot’s update PR creation. For product feedback see: https://github.com/github/feedback/discussions/categories/dependabot-feedback\ndependabot DocsKeeping your dependencies updated automatically with Dependabot version updates - GitHub Docs\nwhat-an-sbom-can-do-for-you\n企业开源分析和思考\n没有免费午餐——再探移动互联网软件供应链安全\n\n","slug":"SCA软件成分分析前期探索","date":"2022-06-17T04:52:00.000Z","categories_index":"","tags_index":"SCA,软件供应链安全,开源漏洞库,SBOM,安全","author_index":"Moses"}]